# script to autogenerate reflection information for struct members
# this file will inspect the source code of modified header files looking for lines like: '#include "reflection_****.h"'
# then, it will generate reflection information for every struct in that file and write it to '../../reflection/reflection_****.h'
# reflection names are not required for the engine to run, but they are very useful for debugging

from dataclasses import dataclass
import sys

# get file name

file_path = ""
if len(sys.argv) > 1:
    file_path = sys.argv[1]
else:
    print("usage: python reflection_names.py <header_file>")
    sys.exit(1)

file_name = file_path.split("/")[-1]

# open header file

f = open(file_path, "r")
lines = f.readlines()
f.close()

# check if file is asking for reflection

is_reflectable = False
has_struct_after_include = False
for l in reversed(lines):
    if l.strip().startswith("struct"):
        has_struct_after_include = True
    if l.strip().startswith("#include"):
        include_file = l.split("\"")[1]
        if include_file.startswith("reflection_"):
            if include_file != "reflection_" + file_name:
                print(f"{file_name} has a wrong reflection include: {include_file}")
                sys.exit(0)
            if has_struct_after_include:
                print(f"{file_name} has a struct defined after the include, which is not allowed")
                sys.exit(0)
            is_reflectable = True
            break

if not is_reflectable:
    sys.exit(0)

# filter and prepare lines

lines = [l.strip() for l in lines]
lines = [l for l in lines if not (l == "" or l.startswith("//") or l.startswith("#"))]

# find structs

@dataclass
class Struct:
    name : str
    members : list

structs = []
reading_struct = False
for l in lines:
    if l.startswith("struct"):
        reading_struct = True
        s = l.split()
        if len(s) == 3 or s[2] == ":" and len(s) == 5:
            structs.append(Struct(s[1], []))
        else:
            print(f"{file_name} has a wrong struct definition: {l}")
            sys.exit(0)
        continue

    if l.startswith("}"):
        reading_struct = False

    if reading_struct:
        if not l.endswith(";"):
            print(f"{file_name} has an invalid line inside a struct: {l}")
            sys.exit(0)

        if "=" in l:
            l = l.split("=")[0]

        s = l[:-1].split()

        if len(s) > 1 and not "static" in s:
            structs[-1].members.append(s[-1])

# !!! namespaces
# !!! inner structs

# begin reflection header

header = f"""//* reflection_{file_name[:-2]}
//      ***THIS IS AN AUTOGENERATED FILE***
//      do not modify manually, reflection_names.py will run each time a header file is modified
//      reflection_**** are helper files for reflection, they declare the names of the members of a struct
//      these are optional when using the engine, but are very useful for debugging or readable serialization
#pragma once

#include "reflection.h"

namespace fresa
{{
"""

# iterate over structs

for s in structs:
    members = ", ".join([f'"{m}"' for m in s.members])
    header += f"    template <> constexpr auto field_names<{s.name}>() {{ return std::array<str_view, {len(s.members)}>{{{members}}}; }}\n"

#Â end reflection header

header += "}"

# write reflection file

f = open(f"../../reflection/reflection_{file_name}", "w")
f.write(header)
f.close()