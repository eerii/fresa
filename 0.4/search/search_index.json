{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"documentation \u00b6 Welcome to fresa , a tiny game engine written in c++20 .","title":"documentation"},{"location":"#documentation","text":"Welcome to fresa , a tiny game engine written in c++20 .","title":"documentation"},{"location":"getting_started/building/","text":"building the project \u00b6 using a template \u00b6 This projects provides a ready to use template with all required dependencies preconfigured. It can be used in two ways, either by creating your own copy (recommended) or by cloning it directly. a. creating a copy Go to josekoalas/aguacate and click on the green button that says \"Use this template\". This requires a GitHub account . You will be taken to a new screen to configure the new repository settings. Set a name and the options you prefer and click on \"Create repository from template\". Now you will have a copy of the template in your profile ready to use. Download it with the following command, replacing your_github_username and repository_name with the appropiate values. git clone --recurse-submodules https://github.com/your_github_username/repository_name cd repository_name b. cloning the template If you don't have a github account or you don't want to create a copy, you can download the template directly by doing: git clone --recurse-submodules https://github.com/josekoalas/aguacate cd aguacate building the project \u00b6 The template repository already includes a CMakeLists.txt with all the configuration needed. Please ensure you have a compatible compiler and a recent version of cmake before proceeding. To configure and build the project use the following two commands respectively: cmake -S . -B build cmake --build build tested compilers \u00b6 These compilers have been tested to work. Older versions might work but are not officially supported. clang 14.0.6 apple clang 14.0.0 gcc 12.1.0 MSVC is mostly working, except for nested constexpr for loops in the math library. There is an issue where these loops don't compile only with MSVC. I already submitted a bug report with a temporary workaround, but I will wait until I hear more before I decide how to proceed. At this time, clang or gcc are recommended. extra: installing compilers \u00b6 This is a very brief and general guide to install the most recent compilers. Your system requirements might vary so please refer to the original instructions when in doubt. debian/ubuntu: # gcc apt install build-essential # clang apt install clang lldb lld macos: If you install XCode or the Command Line Tools it will come with Apple clang. To get the version 14.0, which includes improved support for c++20 , you need to download the beta of XCode 14. Regular clang and gcc can be installed with homebrew : # gcc brew install gcc # clang brew install llvm windows: You can use clang with Visual Studio or install gcc with MinGW . As mentioned above, MSVC is a work in progress. extra: installing cmake \u00b6 CMake is our build system of choice. You can download it from the official website or, if you are using an unix like system, get it from a package manager: debian/ubuntu: apt install cmake # or snap install cmake macos: brew install cmake advanced: manual configuration \u00b6 You can ignore the template and add fresa directly into your project. The main library is located in josekoalas/fresa . Please note when adding includes that include directories are specified without the folder, so you have to specify all include files, not just recursive directories. Also make sure that all required libraries are linked propperly. To use fresa all you need is to include \"engine.h\" and call fresa::run . Configuration parameters are a work in progress. advanced: required libraries \u00b6 fmt : Used for general string formatting, mainly as a basis to the logging system ( log.h ). May be replaced with std::format in the future, but it depends on its capabilities. standard libraries Some compilers don't have full support of all c++20 features. Therefore, while those compilers get support, you can alternatively use this libraries that the standard is based on as a stand in. Once compiler support is widespread these will be removed. range-v3 : For std::ranges . jthread : For std::jthread .","title":"building the project"},{"location":"getting_started/building/#building-the-project","text":"","title":"building the project"},{"location":"getting_started/building/#using-a-template","text":"This projects provides a ready to use template with all required dependencies preconfigured. It can be used in two ways, either by creating your own copy (recommended) or by cloning it directly. a. creating a copy Go to josekoalas/aguacate and click on the green button that says \"Use this template\". This requires a GitHub account . You will be taken to a new screen to configure the new repository settings. Set a name and the options you prefer and click on \"Create repository from template\". Now you will have a copy of the template in your profile ready to use. Download it with the following command, replacing your_github_username and repository_name with the appropiate values. git clone --recurse-submodules https://github.com/your_github_username/repository_name cd repository_name b. cloning the template If you don't have a github account or you don't want to create a copy, you can download the template directly by doing: git clone --recurse-submodules https://github.com/josekoalas/aguacate cd aguacate","title":"using a template"},{"location":"getting_started/building/#building-the-project_1","text":"The template repository already includes a CMakeLists.txt with all the configuration needed. Please ensure you have a compatible compiler and a recent version of cmake before proceeding. To configure and build the project use the following two commands respectively: cmake -S . -B build cmake --build build","title":"building the project"},{"location":"getting_started/building/#tested-compilers","text":"These compilers have been tested to work. Older versions might work but are not officially supported. clang 14.0.6 apple clang 14.0.0 gcc 12.1.0 MSVC is mostly working, except for nested constexpr for loops in the math library. There is an issue where these loops don't compile only with MSVC. I already submitted a bug report with a temporary workaround, but I will wait until I hear more before I decide how to proceed. At this time, clang or gcc are recommended.","title":"tested compilers"},{"location":"getting_started/building/#extra-installing-compilers","text":"This is a very brief and general guide to install the most recent compilers. Your system requirements might vary so please refer to the original instructions when in doubt. debian/ubuntu: # gcc apt install build-essential # clang apt install clang lldb lld macos: If you install XCode or the Command Line Tools it will come with Apple clang. To get the version 14.0, which includes improved support for c++20 , you need to download the beta of XCode 14. Regular clang and gcc can be installed with homebrew : # gcc brew install gcc # clang brew install llvm windows: You can use clang with Visual Studio or install gcc with MinGW . As mentioned above, MSVC is a work in progress.","title":"extra: installing compilers"},{"location":"getting_started/building/#extra-installing-cmake","text":"CMake is our build system of choice. You can download it from the official website or, if you are using an unix like system, get it from a package manager: debian/ubuntu: apt install cmake # or snap install cmake macos: brew install cmake","title":"extra: installing cmake"},{"location":"getting_started/building/#advanced-manual-configuration","text":"You can ignore the template and add fresa directly into your project. The main library is located in josekoalas/fresa . Please note when adding includes that include directories are specified without the folder, so you have to specify all include files, not just recursive directories. Also make sure that all required libraries are linked propperly. To use fresa all you need is to include \"engine.h\" and call fresa::run . Configuration parameters are a work in progress.","title":"advanced: manual configuration"},{"location":"getting_started/building/#advanced-required-libraries","text":"fmt : Used for general string formatting, mainly as a basis to the logging system ( log.h ). May be replaced with std::format in the future, but it depends on its capabilities. standard libraries Some compilers don't have full support of all c++20 features. Therefore, while those compilers get support, you can alternatively use this libraries that the standard is based on as a stand in. Once compiler support is widespread these will be removed. range-v3 : For std::ranges . jthread : For std::jthread .","title":"advanced: required libraries"},{"location":"getting_started/first_project/","text":"a simple program \u00b6 If you are using the template then you already have a minimum main.cpp file that should look something like this: #include \"engine.h\" int main ( int argv , char ** args ) { fresa :: run (); return 0 ; } All you need to run fresa is to import the engine header and call fresa::run() . If you wish to configure how the engine behaves, you can look into the configuration file . This page will be updated when components are added to the engine to explain how to create your own functionality.","title":"a simple program"},{"location":"getting_started/first_project/#a-simple-program","text":"If you are using the template then you already have a minimum main.cpp file that should look something like this: #include \"engine.h\" int main ( int argv , char ** args ) { fresa :: run (); return 0 ; } All you need to run fresa is to import the engine header and call fresa::run() . If you wish to configure how the engine behaves, you can look into the configuration file . This page will be updated when components are added to the engine to explain how to create your own functionality.","title":"a simple program"},{"location":"reference/config/","text":"config \u00b6 The configuration system defined in fresa_config.h allows for configurable constexpr variables. The struct Config contains constexpr virtual methods (a new c++20 feature), allowing to create an interface that can be extended but retaining the compile time definitions. It is a bit more verbose than other approaches, but being able to extend and override constant expressions is very powerful. Look at this example, here we have the original config structure: struct fresa :: Config { constexpr str_view virtual name () const { return \"fresa\" ; }; }; Which can be overwritten as: struct GameConfig : fresa :: Config { constexpr str_view name () const override { return \"aguacate\" ; } }; configuration file \u00b6 fresa allows you to create a configuration file to overwrite the default options. To do so, create a header file and include it in the project. By default the name of the configuration file is config.h , but if you wish to use a different name you can use the FRESA_CONFIG_FILE preprocessor directive as FRESA_CONFIG_FILE = file_name.h (only write the file name, excluding its path). An example configuration file is provided with the template repository, similar to this: config.h #pragma once #include \"fresa_config.h\" namespace fresa { constexpr inline struct GameConfig : Config { //: change the project name to \"my project\" constexpr str_view name () const override { return \"my project\" ; } } config ; } This configuration file: Needs to import fresa_config.h . Creates a struct that extends fresa::Config . Overrides some of the constexpr methods with new configurations. Creates an inline variable named config . If you look at the fresa_config.h code, you will see that the configuration file, if present, is imported back into that header (using guards to avoid compilation loops). That means that the config variable will be available engine-wide, allowing every system to access this overwritten configuration. using configuration \u00b6 All you need to access the configuration variables is to include \"fresa_config.h\" and call any option from config . #include \"fresa_config.h\" void using_configuration () { log :: info ( \"{}\" , config . name ()); } configuration options \u00b6 option type default value name str_view \"fresa\" version std::array<ui8, 3> {0, 4, x} run_tests str_view \"\"","title":"configuration"},{"location":"reference/config/#config","text":"The configuration system defined in fresa_config.h allows for configurable constexpr variables. The struct Config contains constexpr virtual methods (a new c++20 feature), allowing to create an interface that can be extended but retaining the compile time definitions. It is a bit more verbose than other approaches, but being able to extend and override constant expressions is very powerful. Look at this example, here we have the original config structure: struct fresa :: Config { constexpr str_view virtual name () const { return \"fresa\" ; }; }; Which can be overwritten as: struct GameConfig : fresa :: Config { constexpr str_view name () const override { return \"aguacate\" ; } };","title":"config"},{"location":"reference/config/#configuration-file","text":"fresa allows you to create a configuration file to overwrite the default options. To do so, create a header file and include it in the project. By default the name of the configuration file is config.h , but if you wish to use a different name you can use the FRESA_CONFIG_FILE preprocessor directive as FRESA_CONFIG_FILE = file_name.h (only write the file name, excluding its path). An example configuration file is provided with the template repository, similar to this: config.h #pragma once #include \"fresa_config.h\" namespace fresa { constexpr inline struct GameConfig : Config { //: change the project name to \"my project\" constexpr str_view name () const override { return \"my project\" ; } } config ; } This configuration file: Needs to import fresa_config.h . Creates a struct that extends fresa::Config . Overrides some of the constexpr methods with new configurations. Creates an inline variable named config . If you look at the fresa_config.h code, you will see that the configuration file, if present, is imported back into that header (using guards to avoid compilation loops). That means that the config variable will be available engine-wide, allowing every system to access this overwritten configuration.","title":"configuration file"},{"location":"reference/config/#using-configuration","text":"All you need to access the configuration variables is to include \"fresa_config.h\" and call any option from config . #include \"fresa_config.h\" void using_configuration () { log :: info ( \"{}\" , config . name ()); }","title":"using configuration"},{"location":"reference/config/#configuration-options","text":"option type default value name str_view \"fresa\" version std::array<ui8, 3> {0, 4, x} run_tests str_view \"\"","title":"configuration options"},{"location":"reference/coroutines/","text":"coroutines \u00b6","title":"coroutines"},{"location":"reference/coroutines/#coroutines","text":"","title":"coroutines"},{"location":"reference/engine/","text":"engine \u00b6 This is the main class of fresa . Handles initialization, update and cleaning, calling all required systems. run \u00b6 void fresa :: run () This is the main entrypoint of the engine. First it perform the tests defined in the configuration file (if enabled with FRESA_ENABLE_TESTS ). Then calls init before running the update loop. Finally it stops all systems and returns control to the caller function. init \u00b6 void fresa :: detail :: init () Called from run handles system initialization and all work needed before the main update loop. update \u00b6 bool fresa :: detail :: update () Main update loop of the application. The simulation update is decoupled from the frame time, instead being increased in discrete steps of dt . This allows the engine to run independent of frame rate. The implementation is very similar to the one described in the fix your timestep article. stop \u00b6 void fresa :: detail :: stop () Called from run when execution ends. Clear systems in LIFO order (using an std::stack ).","title":"engine"},{"location":"reference/engine/#engine","text":"This is the main class of fresa . Handles initialization, update and cleaning, calling all required systems.","title":"engine"},{"location":"reference/engine/#run","text":"void fresa :: run () This is the main entrypoint of the engine. First it perform the tests defined in the configuration file (if enabled with FRESA_ENABLE_TESTS ). Then calls init before running the update loop. Finally it stops all systems and returns control to the caller function.","title":"run"},{"location":"reference/engine/#init","text":"void fresa :: detail :: init () Called from run handles system initialization and all work needed before the main update loop.","title":"init"},{"location":"reference/engine/#update","text":"bool fresa :: detail :: update () Main update loop of the application. The simulation update is decoupled from the frame time, instead being increased in discrete steps of dt . This allows the engine to run independent of frame rate. The implementation is very similar to the one described in the fix your timestep article.","title":"update"},{"location":"reference/engine/#stop","text":"void fresa :: detail :: stop () Called from run when execution ends. Clear systems in LIFO order (using an std::stack ).","title":"stop"},{"location":"reference/jobs/","text":"jobs \u00b6 ...","title":"job system"},{"location":"reference/jobs/#jobs","text":"...","title":"jobs"},{"location":"reference/math/","text":"math \u00b6 ...","title":"math"},{"location":"reference/math/#math","text":"...","title":"math"},{"location":"reference/system/","text":"system \u00b6 ...","title":"system manager"},{"location":"reference/system/#system","text":"...","title":"system"},{"location":"reference/time/","text":"time \u00b6 Small time management utility based on std::chrono . Defines helpful functions to manage the flow of time. It also imports the chrono literals for time, for example, 1ms . The clock implementation is std::chrono::steady_clock , aliased as fresa::clock . The main function of the library is fresa::time() , which returns the current point in time.","title":"time"},{"location":"reference/time/#time","text":"Small time management utility based on std::chrono . Defines helpful functions to manage the flow of time. It also imports the chrono literals for time, for example, 1ms . The clock implementation is std::chrono::steady_clock , aliased as fresa::clock . The main function of the library is fresa::time() , which returns the current point in time.","title":"time"},{"location":"reference/types/","text":"custom types \u00b6 standard types \u00b6 Defines standard library imports and useful aliases. Also includes feature testing for the latest c++20 features, which in case they are not available it replaces them with compatible libraries. standard library features \u00b6 Features from the standard library will be added with a clear intent, trying to keep them as organized as possible. All imports used will be listed in this file. math <cstdint> for standard integer types <random> for generating pseudo-random numbers <numbers> for mathematical constants, including pi strings std::string (aliased as str ) std::string_view (aliased as str_view) containers common: std::array as the main container, use wherever possible std::vector only for containers that must be variable, preallocation is recommended std::unordered_map for key-value pairs std::map only when ordered access is required <ranges> [ c++20 ] for algorithms and iteration specific: std::deque for lists where a lot of elements are added to or removed at the back std::set for unique identifier lists, has useful mathematical properties std::stack for LIFO containers, for example, system initialization/destruction std::queue and std::priority_queue for other ordered containers metaprograming templates lambdas (and templated lambdas [ c++20 ]) concepts [ c++20 ] std::optional <tuple> compiler feature testing [ c++20 ] std::source_location [ c++20 ] for unit testing (alternative implementation provided) time std::chrono for system independent timers concurrency coroutines [ c++20 ] std::jthread [ c++20 ] for multithreading std::atomic , std::mutex and std::condition_variable for thread syncronization aliases \u00b6 Some standard types are aliased to improve on readability and code clutter. Also, this is made to avoid using the std namespace, as that can bring confusion and errors. I tried to use common and easy to understand aliases, and a table is available with all conversions: type alias std::uint8_t ui8 std::uint16_t ui16 std::uint32_t ui32 std::uint64_t ui64 std::string str std::string_view str_view The namespace aliases are mainly to allow compatibility between the standard library and helper libraries while compilers get support of c++20 . For example, the range-v3 library defines everything in the namespace ranges , while the standard library uses std::ranges . Similarly, in clang coroutine features are under std::experimental , while on gcc they are under std . Once the libraries are homogeneous this aliases might be removed. namespace alias std::ranges ranges std::ranges::views rv std::experimental std_ type name \u00b6 Constexpr compiler-independent type name implementation. constexpr str_view fresa :: type_name_n < TYPE > (); constexpr str_view fresa :: type_name < TYPE > (); There are two versions of the function. type_name_n returns the full type including all namespaces, while type_name removes fresa namespaces and only returns the name of the type. type_name_n < fresa :: detail :: array > () == \"fresa::detail::array\" ; type_name < fresa :: detail :: array > () == \"array\" ; //: while type_name_n < std :: array > () == \"std::array\" ; type_name < std :: array > () == \"std::array\" ; constexpr for \u00b6 Approach of a variety of constexpr for loops. Uses template metaprograming to create the iteration on compile time, supporting constexpr results. integral for Similar to a regular for loop, has a range of integral values [a, b) and calls the function inside each time with a different value of i . In the case of the constexpr for, i is an integral constant which can be used as a constexpr, for example for template parameters. //: regular for for ( int i = 0 ; i < 5 ; i ++ ) { ... } //: constexpr for for_ < 0 , 5 > ([ & ]( auto i ){ ... }); //: also supports a custom increment for_ < 0 , 30 , 3 > ([]( auto i ){ ... }); parameter pack for Recursively calls the function with each of the elements provided. The values can be heterogeneous. for_ ([ & ]( auto a ){ ... }, 2 , 4 , 8 , 16 ); tuple like for Very similar to the previous one, but perhaps more useful. Iterates over the values of a tuple like object, much like a range based for loop. //: range based for loop for ( auto a : some_array ) { ... } //: constexpr tuple-like for loop for_ ([ & ]( auto const & a ){ ... }, std :: make_tuple ( true , 1 , \"hello\" )); string utils \u00b6 string literal Used for passing a string literal as a template parameter. template < str_literal name > void function () { name . value ; } function < \"hey\" > (); lowercase Returns a lowercase string view. Works for constexpr strings. There is also a literal operator for in place conversion. fresa :: lower ( \"FrEsA\" ) == \"fresa\" \"AgUAcAte\" _lower == \"aguacate\" split Parses a string view and returns a range of elements separated by the delimiter (by default a space). The returned object is a range, but can be easily convertible to a vector using ranges::to_vector . auto s_range = split ( \"a,b,c,d\" , ',' ); auto s_vector = s_range | ranges :: to_vector ; //: removes extra delimiters auto s = split ( \"a b c d\" ) | ranges :: to_vector == { \"a\" , \"b\" , \"c\" , \"d\" }; atomic queue \u00b6 spin lock Simple implementation of a spin lock using std::atomic_flag for thread syncronization. Can be used inside std::lock_guard . fresa :: SpinLock lock ; //... { std :: lock_guard < SpinLock > guard ( lock ); //: thread safe code } atomic queue Adaptation of std::queue to be thread safe using SpinLock . Can't be copied, only moved (for example, to emplace in a vector or atomic queues). One of its main usages is for the job system 's worker queues. fresa :: AtomicQueue < T > queue ; //: add to the end of the queue queue . push ( T {}); //: get an item from the front of the queue and remove it // if the queue is empty, return an empty optional std :: optional < T > t = queue . pop (); //: elements left in the queue std :: size_t n = queue . size (); //: clear the queue queue . clear (); coroutines \u00b6 See coroutines .","title":"custom types"},{"location":"reference/types/#custom-types","text":"","title":"custom types"},{"location":"reference/types/#standard-types","text":"Defines standard library imports and useful aliases. Also includes feature testing for the latest c++20 features, which in case they are not available it replaces them with compatible libraries.","title":"standard types"},{"location":"reference/types/#standard-library-features","text":"Features from the standard library will be added with a clear intent, trying to keep them as organized as possible. All imports used will be listed in this file. math <cstdint> for standard integer types <random> for generating pseudo-random numbers <numbers> for mathematical constants, including pi strings std::string (aliased as str ) std::string_view (aliased as str_view) containers common: std::array as the main container, use wherever possible std::vector only for containers that must be variable, preallocation is recommended std::unordered_map for key-value pairs std::map only when ordered access is required <ranges> [ c++20 ] for algorithms and iteration specific: std::deque for lists where a lot of elements are added to or removed at the back std::set for unique identifier lists, has useful mathematical properties std::stack for LIFO containers, for example, system initialization/destruction std::queue and std::priority_queue for other ordered containers metaprograming templates lambdas (and templated lambdas [ c++20 ]) concepts [ c++20 ] std::optional <tuple> compiler feature testing [ c++20 ] std::source_location [ c++20 ] for unit testing (alternative implementation provided) time std::chrono for system independent timers concurrency coroutines [ c++20 ] std::jthread [ c++20 ] for multithreading std::atomic , std::mutex and std::condition_variable for thread syncronization","title":"standard library features"},{"location":"reference/types/#aliases","text":"Some standard types are aliased to improve on readability and code clutter. Also, this is made to avoid using the std namespace, as that can bring confusion and errors. I tried to use common and easy to understand aliases, and a table is available with all conversions: type alias std::uint8_t ui8 std::uint16_t ui16 std::uint32_t ui32 std::uint64_t ui64 std::string str std::string_view str_view The namespace aliases are mainly to allow compatibility between the standard library and helper libraries while compilers get support of c++20 . For example, the range-v3 library defines everything in the namespace ranges , while the standard library uses std::ranges . Similarly, in clang coroutine features are under std::experimental , while on gcc they are under std . Once the libraries are homogeneous this aliases might be removed. namespace alias std::ranges ranges std::ranges::views rv std::experimental std_","title":"aliases"},{"location":"reference/types/#type-name","text":"Constexpr compiler-independent type name implementation. constexpr str_view fresa :: type_name_n < TYPE > (); constexpr str_view fresa :: type_name < TYPE > (); There are two versions of the function. type_name_n returns the full type including all namespaces, while type_name removes fresa namespaces and only returns the name of the type. type_name_n < fresa :: detail :: array > () == \"fresa::detail::array\" ; type_name < fresa :: detail :: array > () == \"array\" ; //: while type_name_n < std :: array > () == \"std::array\" ; type_name < std :: array > () == \"std::array\" ;","title":"type name"},{"location":"reference/types/#constexpr-for","text":"Approach of a variety of constexpr for loops. Uses template metaprograming to create the iteration on compile time, supporting constexpr results. integral for Similar to a regular for loop, has a range of integral values [a, b) and calls the function inside each time with a different value of i . In the case of the constexpr for, i is an integral constant which can be used as a constexpr, for example for template parameters. //: regular for for ( int i = 0 ; i < 5 ; i ++ ) { ... } //: constexpr for for_ < 0 , 5 > ([ & ]( auto i ){ ... }); //: also supports a custom increment for_ < 0 , 30 , 3 > ([]( auto i ){ ... }); parameter pack for Recursively calls the function with each of the elements provided. The values can be heterogeneous. for_ ([ & ]( auto a ){ ... }, 2 , 4 , 8 , 16 ); tuple like for Very similar to the previous one, but perhaps more useful. Iterates over the values of a tuple like object, much like a range based for loop. //: range based for loop for ( auto a : some_array ) { ... } //: constexpr tuple-like for loop for_ ([ & ]( auto const & a ){ ... }, std :: make_tuple ( true , 1 , \"hello\" ));","title":"constexpr for"},{"location":"reference/types/#string-utils","text":"string literal Used for passing a string literal as a template parameter. template < str_literal name > void function () { name . value ; } function < \"hey\" > (); lowercase Returns a lowercase string view. Works for constexpr strings. There is also a literal operator for in place conversion. fresa :: lower ( \"FrEsA\" ) == \"fresa\" \"AgUAcAte\" _lower == \"aguacate\" split Parses a string view and returns a range of elements separated by the delimiter (by default a space). The returned object is a range, but can be easily convertible to a vector using ranges::to_vector . auto s_range = split ( \"a,b,c,d\" , ',' ); auto s_vector = s_range | ranges :: to_vector ; //: removes extra delimiters auto s = split ( \"a b c d\" ) | ranges :: to_vector == { \"a\" , \"b\" , \"c\" , \"d\" };","title":"string utils"},{"location":"reference/types/#atomic-queue","text":"spin lock Simple implementation of a spin lock using std::atomic_flag for thread syncronization. Can be used inside std::lock_guard . fresa :: SpinLock lock ; //... { std :: lock_guard < SpinLock > guard ( lock ); //: thread safe code } atomic queue Adaptation of std::queue to be thread safe using SpinLock . Can't be copied, only moved (for example, to emplace in a vector or atomic queues). One of its main usages is for the job system 's worker queues. fresa :: AtomicQueue < T > queue ; //: add to the end of the queue queue . push ( T {}); //: get an item from the front of the queue and remove it // if the queue is empty, return an empty optional std :: optional < T > t = queue . pop (); //: elements left in the queue std :: size_t n = queue . size (); //: clear the queue queue . clear ();","title":"atomic queue"},{"location":"reference/types/#coroutines","text":"See coroutines .","title":"coroutines"},{"location":"reference/tools/log/","text":"log \u00b6 ...","title":"logging"},{"location":"reference/tools/log/#log","text":"...","title":"log"},{"location":"reference/tools/unit_test/","text":"unit tests \u00b6 ...","title":"unit tests"},{"location":"reference/tools/unit_test/#unit-tests","text":"...","title":"unit tests"}]}