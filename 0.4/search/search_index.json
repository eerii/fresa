{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"documentation \u00b6 Welcome to fresa , a tiny game engine written in c++20 .","title":"documentation"},{"location":"#documentation","text":"Welcome to fresa , a tiny game engine written in c++20 .","title":"documentation"},{"location":"engine_design/design/","text":"engine design \u00b6 data oriented design \u00b6 fresa \ud83c\udf53 will try to adhere to a data oriented design . Object oriented programming is not always suitable to game engines, it can get too messy too soon. I enjoy designing engines with data in mind, with it being separated from the functions that use it, providing cleaner and easier to debug code. It can also be more performant in a variety of situations. There are many articles detailing how data oriented design can be better for many reasons ( insert reference ), however, I will stick to it since I have made engines in OOD and DOD and I like data programming much better. Please note that this engine will not always be 100% perfectly data oriented, since in some problems it makes more sense to take other approaches. Just a quick note, I have seen many places use DOD and ECS used interchangeably. Though fresa \ud83c\udf53 integrates a simple ECS for managing the game entities, an ECS is just an example of what data oriented design can do. It can span all the pieces and frameworks of an engine, it is not wise to reduce it only to an ECS. libraries \u00b6 fresa 's approach to libraries is similar to its approach to language features. Libraries will be only added when they provide a sustancial improvement over hand made code, or at least until I can work on a custom version. For example, vulkan memory allocator significantly improves memory handling in vulkan and it is really well constructed. When choosing a library, its code size will be pretty important. Adding a small one file header library will be preferred to a big and complex project. I will try to only add libraries (or parts of them) which only focus on the problem I'm trying to solve by using them. Also, I would like to be able to easily review all the library code. It will also be nice if they share the same coding style as the engine, for example, with a focus on compile time calculations and with intentful use of new c++ standards. All libraries will be linked in the project template aguacate \ud83e\udd51 as submodules, under the folder deps , so it is effortless to start a new fresa \ud83c\udf53 project with them. They will be also listed here with propper attribution and licensing information. fmt : This library could easily be part of the std library. It is easy to follow, has a really nice syntax and vastly simplifies printing and formatting strings. Besides, it is really performant. I use it as a basis to the logging system ( log.h ), since it also allows to use formatting and colors. It may not be strictly required for our implementation, but a very welcomed quality of life. Also temporary while compilers gain support of std::format . range-v3 : This is a temporary fix since compiler support for the <ranges> of c++20 is not finalised (specially in clang, the compiler I am using). The code will try to import <ranges> , and if not fall back to <range-v3> , which should be pretty much compatible since the standard is based off it. Once compiler support is more widespread it will be removed. jthread : Another temporary fix since std::jthread is not yet supported. Using the library that the standard implementation is based, so there should be no noticeable differences.","title":"engine design"},{"location":"engine_design/design/#engine-design","text":"","title":"engine design"},{"location":"engine_design/design/#data-oriented-design","text":"fresa \ud83c\udf53 will try to adhere to a data oriented design . Object oriented programming is not always suitable to game engines, it can get too messy too soon. I enjoy designing engines with data in mind, with it being separated from the functions that use it, providing cleaner and easier to debug code. It can also be more performant in a variety of situations. There are many articles detailing how data oriented design can be better for many reasons ( insert reference ), however, I will stick to it since I have made engines in OOD and DOD and I like data programming much better. Please note that this engine will not always be 100% perfectly data oriented, since in some problems it makes more sense to take other approaches. Just a quick note, I have seen many places use DOD and ECS used interchangeably. Though fresa \ud83c\udf53 integrates a simple ECS for managing the game entities, an ECS is just an example of what data oriented design can do. It can span all the pieces and frameworks of an engine, it is not wise to reduce it only to an ECS.","title":"data oriented design"},{"location":"engine_design/design/#libraries","text":"fresa 's approach to libraries is similar to its approach to language features. Libraries will be only added when they provide a sustancial improvement over hand made code, or at least until I can work on a custom version. For example, vulkan memory allocator significantly improves memory handling in vulkan and it is really well constructed. When choosing a library, its code size will be pretty important. Adding a small one file header library will be preferred to a big and complex project. I will try to only add libraries (or parts of them) which only focus on the problem I'm trying to solve by using them. Also, I would like to be able to easily review all the library code. It will also be nice if they share the same coding style as the engine, for example, with a focus on compile time calculations and with intentful use of new c++ standards. All libraries will be linked in the project template aguacate \ud83e\udd51 as submodules, under the folder deps , so it is effortless to start a new fresa \ud83c\udf53 project with them. They will be also listed here with propper attribution and licensing information. fmt : This library could easily be part of the std library. It is easy to follow, has a really nice syntax and vastly simplifies printing and formatting strings. Besides, it is really performant. I use it as a basis to the logging system ( log.h ), since it also allows to use formatting and colors. It may not be strictly required for our implementation, but a very welcomed quality of life. Also temporary while compilers gain support of std::format . range-v3 : This is a temporary fix since compiler support for the <ranges> of c++20 is not finalised (specially in clang, the compiler I am using). The code will try to import <ranges> , and if not fall back to <range-v3> , which should be pretty much compatible since the standard is based off it. Once compiler support is more widespread it will be removed. jthread : Another temporary fix since std::jthread is not yet supported. Using the library that the standard implementation is based, so there should be no noticeable differences.","title":"libraries"},{"location":"engine_design/features/","text":"language features \u00b6 fresa \ud83c\udf53 uses the c++20 standard and some of its most recent features. The std library contains many useful structures and design patterns that were implemented in the past few years. I will carefully pick which features I use and document its usage in this file. This is an opinionated engine, features will be added with a clear intent, keeping clutter to a feasible minimum. These are all my opinions and they are not right nor wrong, just how I like to code now. Keeping performance in mind, a key feature of any game engine on a tight per-frame time budget, compile time calculations and templated code will be a fundamental in the design of this engine. There will also be an active attempt to try to avoid macros (except for conditional compilation) and replace them with safer and more readable alternatives where possible. Macros will always be capitalized and clearly indicated. strings \u00b6 std::string (aliased as str) std::string_view (aliased as str_view) containers \u00b6 common: std::array as the main container, use wherever possible std::vector only for containers that must be variable, preallocation is recommended std::unordered_map for key-value pairs std::map only when ordered access is required ranges ( c++20 ) specific: std::deque for lists where a lot of elements are added to or removed at the back std::set for unique identifier lists, useful mathematical properties std::stack for LIFO containers, for example, system initialization/destruction std::queue and std::priority_queue for other ordered containers metaprograming \u00b6 templates lambdas concepts ( c++20 ) std::optional tuples compiler \u00b6 feature testing ( c++20 ) std::source_location ( c++20 ) for unit testing time \u00b6 std::chrono for system independent timers concurrency \u00b6 coroutines ( c++20 ), using experimental branch for clang compilers std::jthread ( c++20 ) for multithreading std::atomic, std::mutex and std::condition_variable for thread syncronization math \u00b6 random library numbers for several constants, including pi","title":"language features"},{"location":"engine_design/features/#language-features","text":"fresa \ud83c\udf53 uses the c++20 standard and some of its most recent features. The std library contains many useful structures and design patterns that were implemented in the past few years. I will carefully pick which features I use and document its usage in this file. This is an opinionated engine, features will be added with a clear intent, keeping clutter to a feasible minimum. These are all my opinions and they are not right nor wrong, just how I like to code now. Keeping performance in mind, a key feature of any game engine on a tight per-frame time budget, compile time calculations and templated code will be a fundamental in the design of this engine. There will also be an active attempt to try to avoid macros (except for conditional compilation) and replace them with safer and more readable alternatives where possible. Macros will always be capitalized and clearly indicated.","title":"language features"},{"location":"engine_design/features/#strings","text":"std::string (aliased as str) std::string_view (aliased as str_view)","title":"strings"},{"location":"engine_design/features/#containers","text":"common: std::array as the main container, use wherever possible std::vector only for containers that must be variable, preallocation is recommended std::unordered_map for key-value pairs std::map only when ordered access is required ranges ( c++20 ) specific: std::deque for lists where a lot of elements are added to or removed at the back std::set for unique identifier lists, useful mathematical properties std::stack for LIFO containers, for example, system initialization/destruction std::queue and std::priority_queue for other ordered containers","title":"containers"},{"location":"engine_design/features/#metaprograming","text":"templates lambdas concepts ( c++20 ) std::optional tuples","title":"metaprograming"},{"location":"engine_design/features/#compiler","text":"feature testing ( c++20 ) std::source_location ( c++20 ) for unit testing","title":"compiler"},{"location":"engine_design/features/#time","text":"std::chrono for system independent timers","title":"time"},{"location":"engine_design/features/#concurrency","text":"coroutines ( c++20 ), using experimental branch for clang compilers std::jthread ( c++20 ) for multithreading std::atomic, std::mutex and std::condition_variable for thread syncronization","title":"concurrency"},{"location":"engine_design/features/#math","text":"random library numbers for several constants, including pi","title":"math"},{"location":"engine_design/style/","text":"coding style \u00b6 naming conventions \u00b6 In fresa \ud83c\udf53 we will use the following name conventions for the different types of objects: snake_case : variables, namespaces camelCase : functions PascalCase : structs, interfaces SCREAMING_CASE : constants, macros namespace fresa { constexpr int NUMBER_OF_OBJECTS = 256 ; struct Object { int position_x ; float velocity_y ; }; Object registerObject ( int start_position ) {} #ifdef USE_VULKAN using IPipeline = vkPipeline ; #endif } Namespaces will always try to be only one word. Interfaces will start with a capital \"I\". These conventions might be broken when working with elements defined in external libraries, such as vulkan . We will also denote the engine name in fully lowercase letters and accompanied by the strawberry emoji, fresa \ud83c\udf53 . All titles of documentation sections will be similarly written in lowercase. comments and documentation \u00b6 //: regular comments //* headers //- todos //? implementation questions //! alert, something went wrong Subsecuent lines of comments (that are not documentation) can be tabbed 2 times to improve readability. It can also be useful to add some extension to the editing software you are using to color code the different comments.","title":"coding style"},{"location":"engine_design/style/#coding-style","text":"","title":"coding style"},{"location":"engine_design/style/#naming-conventions","text":"In fresa \ud83c\udf53 we will use the following name conventions for the different types of objects: snake_case : variables, namespaces camelCase : functions PascalCase : structs, interfaces SCREAMING_CASE : constants, macros namespace fresa { constexpr int NUMBER_OF_OBJECTS = 256 ; struct Object { int position_x ; float velocity_y ; }; Object registerObject ( int start_position ) {} #ifdef USE_VULKAN using IPipeline = vkPipeline ; #endif } Namespaces will always try to be only one word. Interfaces will start with a capital \"I\". These conventions might be broken when working with elements defined in external libraries, such as vulkan . We will also denote the engine name in fully lowercase letters and accompanied by the strawberry emoji, fresa \ud83c\udf53 . All titles of documentation sections will be similarly written in lowercase.","title":"naming conventions"},{"location":"engine_design/style/#comments-and-documentation","text":"//: regular comments //* headers //- todos //? implementation questions //! alert, something went wrong Subsecuent lines of comments (that are not documentation) can be tabbed 2 times to improve readability. It can also be useful to add some extension to the editing software you are using to color code the different comments.","title":"comments and documentation"},{"location":"getting_started/building/","text":"building the project \u00b6 using a template \u00b6 This projects provides a ready to use template with all required dependencies preconfigured. It can be used in two ways, either by creating your own copy (recommended) or by cloning it directly. a. creating a copy Go to josekoalas/aguacate and click on the green button that says \"Use this template\". This requires a GitHub account . You will be taken to a new screen to configure the new repository settings. Set a name and the options you prefer and click on \"Create repository from template\". Now you will have a copy of the template in your profile ready to use. Download it with the following command, replacing your_github_username and repository_name with the appropiate values. git clone --recurse-submodules https://github.com/your_github_username/repository_name cd repository_name b. cloning the template If you don't have a github account or you don't want to create a copy, you can download the template directly by doing: git clone --recurse-submodules https://github.com/josekoalas/aguacate cd aguacate building the project \u00b6 The template repository already includes a CMakeLists.txt with all the configuration needed. Please ensure you have a compatible compiler and a recent version of cmake before proceeding. To configure and build the project use the following two commands respectively: cmake -S . -B build cmake --build build tested compilers \u00b6 These compilers have been tested to work. Older versions might work but are not officially supported. clang 14.0.6 apple clang 14.0.0 gcc 12.1.0 msvc not tested yet installing compilers \u00b6 This is a very brief and general guide to install the most recent compilers. Your system requirements might vary so please refer to the original instructions when in doubt. debian/ubuntu: # gcc apt install build-essential # clang apt install clang lldb lld macos: If you install XCode or the Command Line Tools it will come with Apple clang. To get the version 14.0, which includes improved support for c++20 , you need to download the beta of XCode 14. Regular clang and gcc can be installed with homebrew : # gcc brew install gcc # clang brew install llvm windows: Windows is not tested yet, but the project should compile using either clang or gcc. Alternatively, you could try compiling it with MSVC, I will test it soon to check compatibility. You can use clang with Visual Studio or install gcc with MinGW . installing cmake \u00b6 CMake is our build system of choice. You can download it from the official website or, if you are using an unix like system, get it from a package manager: debian/ubuntu: apt install cmake # or snap install cmake macos: brew install cmake advanced: manual configuration \u00b6 You can ignore the template and add fresa directly into your project. The main library is located in josekoalas/fresa . Please note when adding includes that include directories are specified without the folder, so you have to specify all include files, not just recursive directories. Also make sure that all required libraries are linked propperly. To use fresa all you need is to include \"engine.h\" and call fresa::run . Configuration parameters are a work in progress. advanced: required libraries \u00b6 fmt : Used for general string formatting, mainly as a basis to the logging system ( log.h ). May be replaced with std::format in the future, but it depends on its capabilities. standard libraries Some compilers don't have full support of all c++20 features. Therefore, while those compilers get support, you can alternatively use this libraries that the standard is based on as a stand in. Once compiler support is widespread these will be removed. range-v3 : For std::ranges . jthread : For std::jthread .","title":"building the project"},{"location":"getting_started/building/#building-the-project","text":"","title":"building the project"},{"location":"getting_started/building/#using-a-template","text":"This projects provides a ready to use template with all required dependencies preconfigured. It can be used in two ways, either by creating your own copy (recommended) or by cloning it directly. a. creating a copy Go to josekoalas/aguacate and click on the green button that says \"Use this template\". This requires a GitHub account . You will be taken to a new screen to configure the new repository settings. Set a name and the options you prefer and click on \"Create repository from template\". Now you will have a copy of the template in your profile ready to use. Download it with the following command, replacing your_github_username and repository_name with the appropiate values. git clone --recurse-submodules https://github.com/your_github_username/repository_name cd repository_name b. cloning the template If you don't have a github account or you don't want to create a copy, you can download the template directly by doing: git clone --recurse-submodules https://github.com/josekoalas/aguacate cd aguacate","title":"using a template"},{"location":"getting_started/building/#building-the-project_1","text":"The template repository already includes a CMakeLists.txt with all the configuration needed. Please ensure you have a compatible compiler and a recent version of cmake before proceeding. To configure and build the project use the following two commands respectively: cmake -S . -B build cmake --build build","title":"building the project"},{"location":"getting_started/building/#tested-compilers","text":"These compilers have been tested to work. Older versions might work but are not officially supported. clang 14.0.6 apple clang 14.0.0 gcc 12.1.0 msvc not tested yet","title":"tested compilers"},{"location":"getting_started/building/#installing-compilers","text":"This is a very brief and general guide to install the most recent compilers. Your system requirements might vary so please refer to the original instructions when in doubt. debian/ubuntu: # gcc apt install build-essential # clang apt install clang lldb lld macos: If you install XCode or the Command Line Tools it will come with Apple clang. To get the version 14.0, which includes improved support for c++20 , you need to download the beta of XCode 14. Regular clang and gcc can be installed with homebrew : # gcc brew install gcc # clang brew install llvm windows: Windows is not tested yet, but the project should compile using either clang or gcc. Alternatively, you could try compiling it with MSVC, I will test it soon to check compatibility. You can use clang with Visual Studio or install gcc with MinGW .","title":"installing compilers"},{"location":"getting_started/building/#installing-cmake","text":"CMake is our build system of choice. You can download it from the official website or, if you are using an unix like system, get it from a package manager: debian/ubuntu: apt install cmake # or snap install cmake macos: brew install cmake","title":"installing cmake"},{"location":"getting_started/building/#advanced-manual-configuration","text":"You can ignore the template and add fresa directly into your project. The main library is located in josekoalas/fresa . Please note when adding includes that include directories are specified without the folder, so you have to specify all include files, not just recursive directories. Also make sure that all required libraries are linked propperly. To use fresa all you need is to include \"engine.h\" and call fresa::run . Configuration parameters are a work in progress.","title":"advanced: manual configuration"},{"location":"getting_started/building/#advanced-required-libraries","text":"fmt : Used for general string formatting, mainly as a basis to the logging system ( log.h ). May be replaced with std::format in the future, but it depends on its capabilities. standard libraries Some compilers don't have full support of all c++20 features. Therefore, while those compilers get support, you can alternatively use this libraries that the standard is based on as a stand in. Once compiler support is widespread these will be removed. range-v3 : For std::ranges . jthread : For std::jthread .","title":"advanced: required libraries"}]}