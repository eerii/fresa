{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"documentation \u00b6 Welcome to fresa , a tiny game engine written in c++20 . To get started, check how to build the engine and how to create your first project . If you want to dive into fresa's functionalities, check the reference .","title":"documentation"},{"location":"#documentation","text":"Welcome to fresa , a tiny game engine written in c++20 . To get started, check how to build the engine and how to create your first project . If you want to dive into fresa's functionalities, check the reference .","title":"documentation"},{"location":"getting_started/building/","text":"building the project \u00b6 using a template \u00b6 This projects provides a ready to use template with all required dependencies preconfigured. It can be used in two ways, either by creating your own copy (recommended) or by cloning it directly. a. creating a copy Go to josekoalas/mermelada and click on the green button that says \"Use this template\". This requires a GitHub account . You will be taken to a new screen to configure the new repository settings. Set a name and the options you prefer and click on \"Create repository from template\". Now you will have a copy of the template in your profile ready to use. Download it with the following command, replacing your_github_username and repository_name with the appropiate values. git clone --recurse-submodules https://github.com/your_github_username/repository_name cd repository_name b. cloning the template If you don't have a github account or you don't want to create a copy, you can download the template directly by doing: git clone --recurse-submodules https://github.com/josekoalas/mermelada cd mermelada building the project \u00b6 The template repository already includes a CMakeLists.txt with all the configuration needed. Please ensure you have a compatible compiler and a recent version of cmake before proceeding. To configure and build the project use the following two commands respectively: cmake -S . -B build cmake --build build tested compilers \u00b6 These compilers have been tested to work. Older versions might work but are not officially supported. clang 14.0+ apple clang 14.0+ gcc 12.1+ MSVC is mostly working, except for nested constexpr for loops in the math library. There is an issue where these loops don't compile only with MSVC. I already submitted a bug report with a temporary workaround, and it is pending release. At this time, clang or gcc are recommended. extra: installing compilers \u00b6 This is a very brief and general guide to install the most recent compilers. Your system requirements might vary so please refer to the original instructions when in doubt. debian/ubuntu: # gcc apt install build-essential # clang apt install clang lldb lld macos: If you install XCode or the Command Line Tools it will come with Apple clang. To get the version 14.0, which includes improved support for c++20 , you need to download the beta of XCode 14. Regular clang and gcc can be installed with homebrew : # gcc brew install gcc # clang brew install llvm windows: You can use clang with Visual Studio or install gcc with MinGW . As mentioned above, MSVC is a work in progress. extra: installing cmake \u00b6 CMake is our build system of choice. You can download it from the official website or, if you are using an unix like system, get it from a package manager: debian/ubuntu: apt install cmake # or snap install cmake macos: brew install cmake advanced: manual configuration \u00b6 You can ignore the template and add fresa directly into your project. The main library is located in josekoalas/fresa . Please note when adding includes that include directories are specified without the folder, so you have to specify all include files, not just recursive directories. Also make sure that all required libraries are linked propperly. To use fresa all you need is to include \"engine.h\" and call fresa::run . Configuration parameters are a work in progress. advanced: required libraries \u00b6 fmt [MIT] : Used for general string formatting, mainly as a basis to the logging system ( log.h ). May be replaced with std::format in the future, but it depends on its capabilities. standard libraries Some compilers don't have full support of all c++20 features. Therefore, while those compilers get support, you can alternatively use this libraries that the standard is based on as a stand in. Once compiler support is widespread these will be removed. range-v3 [BSL 1.0] : For std::ranges . jthread [CC BY 4.0] : For std::jthread .","title":"building the project"},{"location":"getting_started/building/#building-the-project","text":"","title":"building the project"},{"location":"getting_started/building/#using-a-template","text":"This projects provides a ready to use template with all required dependencies preconfigured. It can be used in two ways, either by creating your own copy (recommended) or by cloning it directly. a. creating a copy Go to josekoalas/mermelada and click on the green button that says \"Use this template\". This requires a GitHub account . You will be taken to a new screen to configure the new repository settings. Set a name and the options you prefer and click on \"Create repository from template\". Now you will have a copy of the template in your profile ready to use. Download it with the following command, replacing your_github_username and repository_name with the appropiate values. git clone --recurse-submodules https://github.com/your_github_username/repository_name cd repository_name b. cloning the template If you don't have a github account or you don't want to create a copy, you can download the template directly by doing: git clone --recurse-submodules https://github.com/josekoalas/mermelada cd mermelada","title":"using a template"},{"location":"getting_started/building/#building-the-project_1","text":"The template repository already includes a CMakeLists.txt with all the configuration needed. Please ensure you have a compatible compiler and a recent version of cmake before proceeding. To configure and build the project use the following two commands respectively: cmake -S . -B build cmake --build build","title":"building the project"},{"location":"getting_started/building/#tested-compilers","text":"These compilers have been tested to work. Older versions might work but are not officially supported. clang 14.0+ apple clang 14.0+ gcc 12.1+ MSVC is mostly working, except for nested constexpr for loops in the math library. There is an issue where these loops don't compile only with MSVC. I already submitted a bug report with a temporary workaround, and it is pending release. At this time, clang or gcc are recommended.","title":"tested compilers"},{"location":"getting_started/building/#extra-installing-compilers","text":"This is a very brief and general guide to install the most recent compilers. Your system requirements might vary so please refer to the original instructions when in doubt. debian/ubuntu: # gcc apt install build-essential # clang apt install clang lldb lld macos: If you install XCode or the Command Line Tools it will come with Apple clang. To get the version 14.0, which includes improved support for c++20 , you need to download the beta of XCode 14. Regular clang and gcc can be installed with homebrew : # gcc brew install gcc # clang brew install llvm windows: You can use clang with Visual Studio or install gcc with MinGW . As mentioned above, MSVC is a work in progress.","title":"extra: installing compilers"},{"location":"getting_started/building/#extra-installing-cmake","text":"CMake is our build system of choice. You can download it from the official website or, if you are using an unix like system, get it from a package manager: debian/ubuntu: apt install cmake # or snap install cmake macos: brew install cmake","title":"extra: installing cmake"},{"location":"getting_started/building/#advanced-manual-configuration","text":"You can ignore the template and add fresa directly into your project. The main library is located in josekoalas/fresa . Please note when adding includes that include directories are specified without the folder, so you have to specify all include files, not just recursive directories. Also make sure that all required libraries are linked propperly. To use fresa all you need is to include \"engine.h\" and call fresa::run . Configuration parameters are a work in progress.","title":"advanced: manual configuration"},{"location":"getting_started/building/#advanced-required-libraries","text":"fmt [MIT] : Used for general string formatting, mainly as a basis to the logging system ( log.h ). May be replaced with std::format in the future, but it depends on its capabilities. standard libraries Some compilers don't have full support of all c++20 features. Therefore, while those compilers get support, you can alternatively use this libraries that the standard is based on as a stand in. Once compiler support is widespread these will be removed. range-v3 [BSL 1.0] : For std::ranges . jthread [CC BY 4.0] : For std::jthread .","title":"advanced: required libraries"},{"location":"getting_started/first_project/","text":"a simple program \u00b6 If you are using the template then you already have a minimum main.cpp file that should look something like this: #include \"engine.h\" int main ( int argv , char ** args ) { fresa :: run (); return 0 ; } All you need to run fresa is to import the engine header and call fresa::run() . If you wish to configure how the engine behaves, you can look into the configuration file and into the system manager . hello world \u00b6 For this example we are going to use a simple system with an init() function, which will execute its code when the engine is initialized. We will create a hello_world.h file and define this system as so: hello_world.h #pragma once #include \"system.h\" namespace fresa { struct SomeSystem { inline static System < SomeSystem > system ; //: this line registers the system static void init () { //: your code goes here } }; } You also need to include it inside main.cpp : main.cpp #include \"engine.h\" #include \"hello_world.h\" //... other code Now, we can import the logging library and use it to print a message when the callback is executed: hello_world.h #include \"engine.h\" #include \"log.h\" //... other code static void init () { log :: info ( \"hello world!\" ); } If you execute the program now, you will see the message printed in the terminal.","title":"a simple program"},{"location":"getting_started/first_project/#a-simple-program","text":"If you are using the template then you already have a minimum main.cpp file that should look something like this: #include \"engine.h\" int main ( int argv , char ** args ) { fresa :: run (); return 0 ; } All you need to run fresa is to import the engine header and call fresa::run() . If you wish to configure how the engine behaves, you can look into the configuration file and into the system manager .","title":"a simple program"},{"location":"getting_started/first_project/#hello-world","text":"For this example we are going to use a simple system with an init() function, which will execute its code when the engine is initialized. We will create a hello_world.h file and define this system as so: hello_world.h #pragma once #include \"system.h\" namespace fresa { struct SomeSystem { inline static System < SomeSystem > system ; //: this line registers the system static void init () { //: your code goes here } }; } You also need to include it inside main.cpp : main.cpp #include \"engine.h\" #include \"hello_world.h\" //... other code Now, we can import the logging library and use it to print a message when the callback is executed: hello_world.h #include \"engine.h\" #include \"log.h\" //... other code static void init () { log :: info ( \"hello world!\" ); } If you execute the program now, you will see the message printed in the terminal.","title":"hello world"},{"location":"getting_started/working_with_entities/","text":"working with entities \u00b6 Now you are ready to use the ecs features of fresa, creating and managing a set of entities and components. create a component \u00b6 In fresa all entities are made of a collection of components. A component can be any arbitrary data structure, even a simple type. However, it is recommended to create specific structs for each component. An entity can't have two components of the same type. An example of how to define a component is as follows: struct PositionComponent { float x ; float y ; }; adding an entity \u00b6 To add an entity you need to create a scene, which is a container for all the component pools and entities. Then, you can use the method scene.add(...) to add an entity to the scene with the specified list of componets. scene.add() can be called with zero, one or multiple components. In this case we are going to import the \"ecs.h\" header and then add an entity with the position component we initialized before. #include \"ecs.h\" //... ecs :: Scene scene ; ecs :: EntityID entity = scene . add ( PositionComponent { 1.0f , 3.0f }); accessing components \u00b6 You can get a specific component from an entity using scene.get<C>(entity) . It returns an optional encapsulating a reference to the component value. If the entity doesn't have the component, it returns an empty optional. Following the previous example you can modify the position of the entity like so: auto & position = scene . get < PositionComponent > ( entity ); if ( position . has_value ()) position . value (). x = 2.0f ; Using an optional is verbose in this case, however, there is another way to efficiently access components, and that is with views. views \u00b6 A view is an iterator over a range of entities with one or more components. For example, you can iterate over all entities with PositionComponent , or all entities with both PositionComponent and VelocityComponent . These are the building blocks of systems. Lets say we want to move all entities in the x direction. We can create a view that does that like so: for ( auto [ entity , position ] : ecs :: View < PositionComponent > ( scene )()) { position . x += 1.0f ; } The view can be used directly inside a for loop (calling it with () at the end). It will return a tuple of values with the entity id and the component references you asked for, in this case PositionComponent . You can operate on the components easily. This will run for all entities that match the criteria. Lets see another example: struct ColorComponent { str color_name ; }; for ( auto [ entity , position , color ] : ecs :: View < PositionComponent , ColorComponent > ( scene )()) { log :: info ( \"the entity at ({}, {}) has the color {}\" , position . x , position . y , color . color_name ); } full example \u00b6 Lets create a final example, this time, we will find the entity that is the furthest from the origin. We will use a system init() function to run this code for now. example.h #pragma once #include \"system.h\" #include \"ecs.h #include \" log.h\" struct PositionComponent { float x ; float y ; }; namespace fresa { struct SomeSystem { inline static System < SomeSystem > system ; static void init () { ecs :: Scene scene ; scene . add ( PositionComponent { 1.0f , 3.0f }); scene . add ( PositionComponent { 2.0f , 1.5f }); scene . add ( PositionComponent { -7.0f , -3.0f }); //: this is the furthest from the origin scene . add ( PositionComponent { -1.2f , -0.5f }); ecs :: Index furthest ; auto norm = []( const PositionComponent & p ) { return std :: sqrt ( p . x * p . x + p . y * p . y ); }; for ( auto [ entity , position ] : ecs :: View < PositionComponent > ( scene )()) { PositionComponent & max_pos = scene . get < PositionComponent > ( ecs :: id ( furthest , 0 )). value (); if ( norm ( position ) > norm ( max_pos )) furthest = entity ; } log :: info ( \"the furthest entity is {}\" , furthest . value ); } }; }","title":"working with entities"},{"location":"getting_started/working_with_entities/#working-with-entities","text":"Now you are ready to use the ecs features of fresa, creating and managing a set of entities and components.","title":"working with entities"},{"location":"getting_started/working_with_entities/#create-a-component","text":"In fresa all entities are made of a collection of components. A component can be any arbitrary data structure, even a simple type. However, it is recommended to create specific structs for each component. An entity can't have two components of the same type. An example of how to define a component is as follows: struct PositionComponent { float x ; float y ; };","title":"create a component"},{"location":"getting_started/working_with_entities/#adding-an-entity","text":"To add an entity you need to create a scene, which is a container for all the component pools and entities. Then, you can use the method scene.add(...) to add an entity to the scene with the specified list of componets. scene.add() can be called with zero, one or multiple components. In this case we are going to import the \"ecs.h\" header and then add an entity with the position component we initialized before. #include \"ecs.h\" //... ecs :: Scene scene ; ecs :: EntityID entity = scene . add ( PositionComponent { 1.0f , 3.0f });","title":"adding an entity"},{"location":"getting_started/working_with_entities/#accessing-components","text":"You can get a specific component from an entity using scene.get<C>(entity) . It returns an optional encapsulating a reference to the component value. If the entity doesn't have the component, it returns an empty optional. Following the previous example you can modify the position of the entity like so: auto & position = scene . get < PositionComponent > ( entity ); if ( position . has_value ()) position . value (). x = 2.0f ; Using an optional is verbose in this case, however, there is another way to efficiently access components, and that is with views.","title":"accessing components"},{"location":"getting_started/working_with_entities/#views","text":"A view is an iterator over a range of entities with one or more components. For example, you can iterate over all entities with PositionComponent , or all entities with both PositionComponent and VelocityComponent . These are the building blocks of systems. Lets say we want to move all entities in the x direction. We can create a view that does that like so: for ( auto [ entity , position ] : ecs :: View < PositionComponent > ( scene )()) { position . x += 1.0f ; } The view can be used directly inside a for loop (calling it with () at the end). It will return a tuple of values with the entity id and the component references you asked for, in this case PositionComponent . You can operate on the components easily. This will run for all entities that match the criteria. Lets see another example: struct ColorComponent { str color_name ; }; for ( auto [ entity , position , color ] : ecs :: View < PositionComponent , ColorComponent > ( scene )()) { log :: info ( \"the entity at ({}, {}) has the color {}\" , position . x , position . y , color . color_name ); }","title":"views"},{"location":"getting_started/working_with_entities/#full-example","text":"Lets create a final example, this time, we will find the entity that is the furthest from the origin. We will use a system init() function to run this code for now. example.h #pragma once #include \"system.h\" #include \"ecs.h #include \" log.h\" struct PositionComponent { float x ; float y ; }; namespace fresa { struct SomeSystem { inline static System < SomeSystem > system ; static void init () { ecs :: Scene scene ; scene . add ( PositionComponent { 1.0f , 3.0f }); scene . add ( PositionComponent { 2.0f , 1.5f }); scene . add ( PositionComponent { -7.0f , -3.0f }); //: this is the furthest from the origin scene . add ( PositionComponent { -1.2f , -0.5f }); ecs :: Index furthest ; auto norm = []( const PositionComponent & p ) { return std :: sqrt ( p . x * p . x + p . y * p . y ); }; for ( auto [ entity , position ] : ecs :: View < PositionComponent > ( scene )()) { PositionComponent & max_pos = scene . get < PositionComponent > ( ecs :: id ( furthest , 0 )). value (); if ( norm ( position ) > norm ( max_pos )) furthest = entity ; } log :: info ( \"the furthest entity is {}\" , furthest . value ); } }; }","title":"full example"},{"location":"reference/config/","text":"config \u00b6 The configuration system defined in fresa_config.h includes three types of configuration variables: EngineConfig : Compile time variables that change the way the engine work. These are for things like enabling different parts of the engine or values that don't change. RunConfig : Run time modifiable values, for example, the settings menus or options that change with the player's input. DebugConfig : Also run time values, but are disabled in production builds. All usage of this must be guarded using the FRESA_DEBUG directive. Useful for debug toggles during development. engine config \u00b6 The struct EngineConfig contains constexpr virtual methods (a new c++20 feature), allowing to create an interface that can be extended but retaining the compile time definitions. It is a bit more verbose than other approaches, but being able to extend and override constant expressions is very powerful. Look at this example, here we have the original config structure: struct fresa :: EngineConfig { constexpr str_view virtual name () const { return \"fresa\" ; }; }; Which can be overwritten as: struct _EngineConfig : fresa :: EngineConfig { //: change the project name to \"mermelada\" constexpr str_view name () const override { return \"mermelada\" ; } }; configuration file \u00b6 fresa allows you to create an optional configuration file to overwrite the default options. To do so, create a header file and include it in the project. By default the name of the configuration file is config.h , but if you wish to use a different name you can use the FRESA_CONFIG_FILE preprocessor directive as FRESA_CONFIG_FILE = file_name.h (only write the file name, excluding its path). An example configuration file is provided with the template repository, similar to this: config.h #pragma once #include \"fresa_config.h\" namespace fresa { constexpr inline struct _EngineConfig : EngineConfig { constexpr str_view name () const override { return \"my project\" ; } } engine_config ; inline RunConfig config { . something = \"initial value\" }; #ifdef FRESA_DEBUG inline struct DebugConfig debug_config {}; #endif } If you chose to create a configuration file, it needs to: Import fresa_config.h . (optional) Create a struct that extends fresa::EngineConfig to override some of the constexpr methods with new configurations. (optional) Create structs that extend fresa::RunConfig and fresa::DebugConfig . Create inline variables named engine_config , config and debug_config . Even if you don't modify the default options of some of these structs, you need to define all three variables (only if you create a configuration file) . These variables must be either of the original struct's types or a derived type. engine_config also needs to be constexpr. If you look at fresa_config.h , you will see that the configuration file, if present, is imported back into that header (using guards to avoid compilation loops). That means that the config variables will be available engine-wide, allowing every system to access this overwritten configuration. using configuration \u00b6 All you need to access the configuration variables is to include \"fresa_config.h\" and call any option from engine_config , run_config or debug_config . Note that the values in engine config are functions, so they must be called. #include \"fresa_config.h\" void using_configuration () { log :: info ( \"{}\" , engine_config . name ()); if constexpr ( engine_config . version (). at ( 0 ) == 0 ) // engine config can be used in compile time expressions log :: info ( \"alpha\" ); run_config . player_name = \"mango\" ; // run and debug config are modifyable #ifdef FRESA_DEBUG if ( debug_config . show_debug_artifacts ) // debug config must be guarded render_debug (); #endif } configuration options \u00b6 engine option type default value name str_view \"fresa\" version std::array<ui8, 3> {0, 4, x} run_tests str_view \"\" enable_assertions bool false log_level ui32 0b0000111 ecs_page_size ui32 256 run option type default value debug option type default value","title":"configuration"},{"location":"reference/config/#config","text":"The configuration system defined in fresa_config.h includes three types of configuration variables: EngineConfig : Compile time variables that change the way the engine work. These are for things like enabling different parts of the engine or values that don't change. RunConfig : Run time modifiable values, for example, the settings menus or options that change with the player's input. DebugConfig : Also run time values, but are disabled in production builds. All usage of this must be guarded using the FRESA_DEBUG directive. Useful for debug toggles during development.","title":"config"},{"location":"reference/config/#engine-config","text":"The struct EngineConfig contains constexpr virtual methods (a new c++20 feature), allowing to create an interface that can be extended but retaining the compile time definitions. It is a bit more verbose than other approaches, but being able to extend and override constant expressions is very powerful. Look at this example, here we have the original config structure: struct fresa :: EngineConfig { constexpr str_view virtual name () const { return \"fresa\" ; }; }; Which can be overwritten as: struct _EngineConfig : fresa :: EngineConfig { //: change the project name to \"mermelada\" constexpr str_view name () const override { return \"mermelada\" ; } };","title":"engine config"},{"location":"reference/config/#configuration-file","text":"fresa allows you to create an optional configuration file to overwrite the default options. To do so, create a header file and include it in the project. By default the name of the configuration file is config.h , but if you wish to use a different name you can use the FRESA_CONFIG_FILE preprocessor directive as FRESA_CONFIG_FILE = file_name.h (only write the file name, excluding its path). An example configuration file is provided with the template repository, similar to this: config.h #pragma once #include \"fresa_config.h\" namespace fresa { constexpr inline struct _EngineConfig : EngineConfig { constexpr str_view name () const override { return \"my project\" ; } } engine_config ; inline RunConfig config { . something = \"initial value\" }; #ifdef FRESA_DEBUG inline struct DebugConfig debug_config {}; #endif } If you chose to create a configuration file, it needs to: Import fresa_config.h . (optional) Create a struct that extends fresa::EngineConfig to override some of the constexpr methods with new configurations. (optional) Create structs that extend fresa::RunConfig and fresa::DebugConfig . Create inline variables named engine_config , config and debug_config . Even if you don't modify the default options of some of these structs, you need to define all three variables (only if you create a configuration file) . These variables must be either of the original struct's types or a derived type. engine_config also needs to be constexpr. If you look at fresa_config.h , you will see that the configuration file, if present, is imported back into that header (using guards to avoid compilation loops). That means that the config variables will be available engine-wide, allowing every system to access this overwritten configuration.","title":"configuration file"},{"location":"reference/config/#using-configuration","text":"All you need to access the configuration variables is to include \"fresa_config.h\" and call any option from engine_config , run_config or debug_config . Note that the values in engine config are functions, so they must be called. #include \"fresa_config.h\" void using_configuration () { log :: info ( \"{}\" , engine_config . name ()); if constexpr ( engine_config . version (). at ( 0 ) == 0 ) // engine config can be used in compile time expressions log :: info ( \"alpha\" ); run_config . player_name = \"mango\" ; // run and debug config are modifyable #ifdef FRESA_DEBUG if ( debug_config . show_debug_artifacts ) // debug config must be guarded render_debug (); #endif }","title":"using configuration"},{"location":"reference/config/#configuration-options","text":"engine option type default value name str_view \"fresa\" version std::array<ui8, 3> {0, 4, x} run_tests str_view \"\" enable_assertions bool false log_level ui32 0b0000111 ecs_page_size ui32 256 run option type default value debug option type default value","title":"configuration options"},{"location":"reference/coroutines/","text":"coroutines \u00b6 Coroutines are a new feature in c++20 that allow for functions to stop and resume execution later. It introduces three new keywords, co_await , co_yield and co_return . However, the implementation in the standard is missing the basic primitives which would allow for easier creation of coroutines, but these are suppossed to come later with c++23 . The cppcoro library is an excelent implementation of most of these features. Since in fresa coroutines are used very sparsely, mainly to easily use the job system , a custom very basic implementation is made. For a very good list of coroutine resources, see this gist by MattPD, which includes links to many talks and articles explaining the new features. The fresa implementation derives from the talks on a coroutine job system by Tanki Zhang ( github ) and the vienna job system by Helmut Hlavacs ( github ), as well as the magnificent blog posts of Lewis Baker , David Mazi\u00e8res and Rainer Grimm . It defines three base types: promises, futures and awaitables. promises \u00b6 A promise is the implementation of the promise_type that all futures require in c++20 . It must specify how the coroutine behaves when it is initialized and when it is finalized, when a value is yielded from it, and it must return a future object. In fresa there are PromiseBase , which is an untemplated promise base type that contain general definitions. It suspends always when a coroutine is started, so it must explicitly be resumed. It also ignores any exception by design. Finally, it includes an unspecialized std::coroutine_handle<> handle , which is used to control the flow of the coroutine. Then an specialization of promises is made separately for regular and void types in Promise<T> . They create the get_return_object to a Future<P, T> , and always suspend on finish and yielding. The Promise<void> has a return_void and doesn't require the use of co_return , while the Promise<T> has a return_value which can be stored in the promise. futures \u00b6 All coroutine functions must return a Future<P, T> object, which encapsulates the state of the coroutine and can be used to access the underlying promise and handle. FutureBase only contains a pointer to the untyped promise type for type erasure purposes. Its child Future<P, T> defines the promise_type and is in turned passed to the underlying promise to be used by get_return_object . A simplification of notation is provided with FuturePromise<T> = Future<Promise<T>, T> . awaitables \u00b6 These define how the coroutine suspends with await_ready , await_suspend and await_resume . The trivial awaitables defined by the standard are std::suspend_always and std::suspend_never . Custom awaitables can be created, and are in fact an essential part of the job system . Ok, this was a mess. This is probably the least clear article in the documentation section due to the nature of how coroutines are implemented in c++ . This will need a rewrite with an extensive explanation of how they work. For now, if you want to dive deep into coroutines, take a look at the links I mentioned before, and lets see a practical example for now to clarify things. simple yield counter \u00b6 FuturePromise < int > counter_yield () { for ( int i = 0 ;; i ++ ) co_yield i ; } //... auto c = counter_yield (); c . handle . resume (); for ( int i = 0 ; i < 3 ; i ++ ) { log :: info ( c . handle . promise (). value . value ()); c . handle (); } c . handle . destroy (); > 0 > 1 > 2 This example shows how to create an infinite counter using co_yield and our simple future type. You can see more examples in the type unit test file.","title":"coroutines"},{"location":"reference/coroutines/#coroutines","text":"Coroutines are a new feature in c++20 that allow for functions to stop and resume execution later. It introduces three new keywords, co_await , co_yield and co_return . However, the implementation in the standard is missing the basic primitives which would allow for easier creation of coroutines, but these are suppossed to come later with c++23 . The cppcoro library is an excelent implementation of most of these features. Since in fresa coroutines are used very sparsely, mainly to easily use the job system , a custom very basic implementation is made. For a very good list of coroutine resources, see this gist by MattPD, which includes links to many talks and articles explaining the new features. The fresa implementation derives from the talks on a coroutine job system by Tanki Zhang ( github ) and the vienna job system by Helmut Hlavacs ( github ), as well as the magnificent blog posts of Lewis Baker , David Mazi\u00e8res and Rainer Grimm . It defines three base types: promises, futures and awaitables.","title":"coroutines"},{"location":"reference/coroutines/#promises","text":"A promise is the implementation of the promise_type that all futures require in c++20 . It must specify how the coroutine behaves when it is initialized and when it is finalized, when a value is yielded from it, and it must return a future object. In fresa there are PromiseBase , which is an untemplated promise base type that contain general definitions. It suspends always when a coroutine is started, so it must explicitly be resumed. It also ignores any exception by design. Finally, it includes an unspecialized std::coroutine_handle<> handle , which is used to control the flow of the coroutine. Then an specialization of promises is made separately for regular and void types in Promise<T> . They create the get_return_object to a Future<P, T> , and always suspend on finish and yielding. The Promise<void> has a return_void and doesn't require the use of co_return , while the Promise<T> has a return_value which can be stored in the promise.","title":"promises"},{"location":"reference/coroutines/#futures","text":"All coroutine functions must return a Future<P, T> object, which encapsulates the state of the coroutine and can be used to access the underlying promise and handle. FutureBase only contains a pointer to the untyped promise type for type erasure purposes. Its child Future<P, T> defines the promise_type and is in turned passed to the underlying promise to be used by get_return_object . A simplification of notation is provided with FuturePromise<T> = Future<Promise<T>, T> .","title":"futures"},{"location":"reference/coroutines/#awaitables","text":"These define how the coroutine suspends with await_ready , await_suspend and await_resume . The trivial awaitables defined by the standard are std::suspend_always and std::suspend_never . Custom awaitables can be created, and are in fact an essential part of the job system . Ok, this was a mess. This is probably the least clear article in the documentation section due to the nature of how coroutines are implemented in c++ . This will need a rewrite with an extensive explanation of how they work. For now, if you want to dive deep into coroutines, take a look at the links I mentioned before, and lets see a practical example for now to clarify things.","title":"awaitables"},{"location":"reference/coroutines/#simple-yield-counter","text":"FuturePromise < int > counter_yield () { for ( int i = 0 ;; i ++ ) co_yield i ; } //... auto c = counter_yield (); c . handle . resume (); for ( int i = 0 ; i < 3 ; i ++ ) { log :: info ( c . handle . promise (). value . value ()); c . handle (); } c . handle . destroy (); > 0 > 1 > 2 This example shows how to create an infinite counter using co_yield and our simple future type. You can see more examples in the type unit test file.","title":"simple yield counter"},{"location":"reference/ecs/","text":"ecs \u00b6 systems \u00b6 A system is a part of fresa that has a certain structure and is used to change how the engine behaves. By creating different functions, a system can execute code at the start, at the end or in the update loop. This is a key part of the entity-component-system architecture, but can also be used for systems that don't interact with the ecs directly, such as the job system. You can define a system in a struct-like fashion: struct SystemA { inline static System < SystemA > system ; static void init () { /* ... */ } } There are two ways to register a system inside the manager, either by using system::add() or by creating a static member of type System<> , which will call add automaticaly on initialization. It is important to note that for systems to be registered, their header file must be included in at least one source file. Systems can contain these functions: init() : called once in the engine initialization, in order of priority. update() : called each simulation frame the update loop, in order of priority. stop() : called once in the engine shutdown, in reverse order of priority. An example of a system can be as follows: int count ; struct CountingSystem { inline static System < CountingSystem > system ; static void init () { count = 0 ; } static void update () { count ++ ; } static void stop () { log :: info ( \"count: {}\" , count ); } } entities \u00b6 In this ecs system, entities are just an id that can be used to access components from a pool. They are composed of an index and a version, both of them 16 bits, creating a total of 32 bits for the entity id, being the lower 16 bits the index and the upper 16 bits the version. The version is incremented each time the entity id is reused by a new entity. ecs :: EntityID e = id ( 0 , 0 ); //: create an entity from an index and a version ecs :: Index i = index ( e ); //: get the entity index ecs :: Version v = version ( e ); //: get the entity version constexpr ecs :: EntityID invalid_entity = id ( -1 , 0 ); //: this is an invalid entity defined for checking if an entity id is valid components \u00b6 Components are structs of data asociated to entities. Theoretically, components can be any type of data, even fundamental types such as int . However, for clarity, it is recommended to make each component type a struct. Entities can't have more than one component of the same type. struct PositionComponent { float x ; float y ; }; These components are stored in ComponentPool objects, that function similar to a sparse allocator. Inside it there is a sparse array of all entity ids that map to a dense array of packed component data. There is actually a third array, with the same layout of the dense one, but this one mapping back to the position inside the sparse array. This is done for faster lookup in exchange for a slightly higher memory footprint. scenes \u00b6 The scene object exists to manage entities and component pools. It has a hash map of component pools that uses a constexpr type hash as the key. To get a component pool of a specific type from this map use scene.cpool<Component>() . If a component pool doesn't exist, this function will create it. For regular usage, you can use the dedicated functions to manage entities: ecs :: Scene scene ; //: create a scene ecs :: EntityID e = scene . add ( PositionComponent { 1.0f , 2.0f }); //: create an entity with a position component ecs :: EntityID e = scene . add ( ComponentA {}, ComponentB {}); //: create an entity with multiple components scene . remove ( e ); //: remove the entity auto position = scene . get < PositionComponent > ( e ); //: get the position component of the entity The last line indicates how to get a component from an entity. The result is a std::optional<> that is null if the entity doesn't have the component. If it does have it, then the optional contains a reference to the underlying component in the sparse set. views \u00b6 Views are a way to iterate over entities and components. They will iterate over all entities that have all the components in the view. This is key for writing systems that operate on entities. auto view = ecs :: View < PositionComponent > ( scene ); for ( auto [ e , position ] : view ()) { //... } The view range can accessed by using the operator () , using a range-based for loop. It will decompose in a tuple of the entity id and the components currently iterating. A view can be defined for multiple components. for ( auto [ e , a , b ] : ecs :: View < ComponentA , ComponentB > ( scene )()) { //... } You can read and modify the component values inside of the for loop, but the entity id is read only. Please note that unlike other range based for loops, no & is written before the square brackets, but the compontents inside are still references. This has to do with how ranges::zip works. There is the possibility to iterate over just the data, without the entity id, by using the data() function. for ( auto & position : ecs :: View < ComponentPosition > ( scene ). data ()) { //... } for ( auto [ a , b ] : ecs :: View < ComponentA , ComponentB > ( scene ). data () s ) { //... }","title":"ecs"},{"location":"reference/ecs/#ecs","text":"","title":"ecs"},{"location":"reference/ecs/#systems","text":"A system is a part of fresa that has a certain structure and is used to change how the engine behaves. By creating different functions, a system can execute code at the start, at the end or in the update loop. This is a key part of the entity-component-system architecture, but can also be used for systems that don't interact with the ecs directly, such as the job system. You can define a system in a struct-like fashion: struct SystemA { inline static System < SystemA > system ; static void init () { /* ... */ } } There are two ways to register a system inside the manager, either by using system::add() or by creating a static member of type System<> , which will call add automaticaly on initialization. It is important to note that for systems to be registered, their header file must be included in at least one source file. Systems can contain these functions: init() : called once in the engine initialization, in order of priority. update() : called each simulation frame the update loop, in order of priority. stop() : called once in the engine shutdown, in reverse order of priority. An example of a system can be as follows: int count ; struct CountingSystem { inline static System < CountingSystem > system ; static void init () { count = 0 ; } static void update () { count ++ ; } static void stop () { log :: info ( \"count: {}\" , count ); } }","title":"systems"},{"location":"reference/ecs/#entities","text":"In this ecs system, entities are just an id that can be used to access components from a pool. They are composed of an index and a version, both of them 16 bits, creating a total of 32 bits for the entity id, being the lower 16 bits the index and the upper 16 bits the version. The version is incremented each time the entity id is reused by a new entity. ecs :: EntityID e = id ( 0 , 0 ); //: create an entity from an index and a version ecs :: Index i = index ( e ); //: get the entity index ecs :: Version v = version ( e ); //: get the entity version constexpr ecs :: EntityID invalid_entity = id ( -1 , 0 ); //: this is an invalid entity defined for checking if an entity id is valid","title":"entities"},{"location":"reference/ecs/#components","text":"Components are structs of data asociated to entities. Theoretically, components can be any type of data, even fundamental types such as int . However, for clarity, it is recommended to make each component type a struct. Entities can't have more than one component of the same type. struct PositionComponent { float x ; float y ; }; These components are stored in ComponentPool objects, that function similar to a sparse allocator. Inside it there is a sparse array of all entity ids that map to a dense array of packed component data. There is actually a third array, with the same layout of the dense one, but this one mapping back to the position inside the sparse array. This is done for faster lookup in exchange for a slightly higher memory footprint.","title":"components"},{"location":"reference/ecs/#scenes","text":"The scene object exists to manage entities and component pools. It has a hash map of component pools that uses a constexpr type hash as the key. To get a component pool of a specific type from this map use scene.cpool<Component>() . If a component pool doesn't exist, this function will create it. For regular usage, you can use the dedicated functions to manage entities: ecs :: Scene scene ; //: create a scene ecs :: EntityID e = scene . add ( PositionComponent { 1.0f , 2.0f }); //: create an entity with a position component ecs :: EntityID e = scene . add ( ComponentA {}, ComponentB {}); //: create an entity with multiple components scene . remove ( e ); //: remove the entity auto position = scene . get < PositionComponent > ( e ); //: get the position component of the entity The last line indicates how to get a component from an entity. The result is a std::optional<> that is null if the entity doesn't have the component. If it does have it, then the optional contains a reference to the underlying component in the sparse set.","title":"scenes"},{"location":"reference/ecs/#views","text":"Views are a way to iterate over entities and components. They will iterate over all entities that have all the components in the view. This is key for writing systems that operate on entities. auto view = ecs :: View < PositionComponent > ( scene ); for ( auto [ e , position ] : view ()) { //... } The view range can accessed by using the operator () , using a range-based for loop. It will decompose in a tuple of the entity id and the components currently iterating. A view can be defined for multiple components. for ( auto [ e , a , b ] : ecs :: View < ComponentA , ComponentB > ( scene )()) { //... } You can read and modify the component values inside of the for loop, but the entity id is read only. Please note that unlike other range based for loops, no & is written before the square brackets, but the compontents inside are still references. This has to do with how ranges::zip works. There is the possibility to iterate over just the data, without the entity id, by using the data() function. for ( auto & position : ecs :: View < ComponentPosition > ( scene ). data ()) { //... } for ( auto [ a , b ] : ecs :: View < ComponentA , ComponentB > ( scene ). data () s ) { //... }","title":"views"},{"location":"reference/engine/","text":"engine \u00b6 This is the main class of fresa . Handles initialization, update and cleaning, calling all required systems. run \u00b6 void fresa :: run () This is the main entrypoint of the engine. First it perform the tests defined in the configuration file (if enabled with FRESA_ENABLE_TESTS ). Then calls init before running the update loop. Finally it stops all systems and returns control to the caller function. init \u00b6 void fresa :: detail :: init () Called from run handles system initialization and all work needed before the main update loop. update \u00b6 bool fresa :: detail :: update () Main update loop of the application. The simulation update is decoupled from the frame time, instead being increased in discrete steps of dt . This allows the engine to run independent of frame rate. The implementation is very similar to the one described in the fix your timestep article. stop \u00b6 void fresa :: detail :: stop () Called from run when execution ends. Clear systems in LIFO order (using an std::stack ).","title":"engine"},{"location":"reference/engine/#engine","text":"This is the main class of fresa . Handles initialization, update and cleaning, calling all required systems.","title":"engine"},{"location":"reference/engine/#run","text":"void fresa :: run () This is the main entrypoint of the engine. First it perform the tests defined in the configuration file (if enabled with FRESA_ENABLE_TESTS ). Then calls init before running the update loop. Finally it stops all systems and returns control to the caller function.","title":"run"},{"location":"reference/engine/#init","text":"void fresa :: detail :: init () Called from run handles system initialization and all work needed before the main update loop.","title":"init"},{"location":"reference/engine/#update","text":"bool fresa :: detail :: update () Main update loop of the application. The simulation update is decoupled from the frame time, instead being increased in discrete steps of dt . This allows the engine to run independent of frame rate. The implementation is very similar to the one described in the fix your timestep article.","title":"update"},{"location":"reference/engine/#stop","text":"void fresa :: detail :: stop () Called from run when execution ends. Clear systems in LIFO order (using an std::stack ).","title":"stop"},{"location":"reference/events/","text":"events \u00b6 actively developing...","title":"events"},{"location":"reference/events/#events","text":"actively developing...","title":"events"},{"location":"reference/jobs/","text":"jobs \u00b6 actively developing...","title":"job system"},{"location":"reference/jobs/#jobs","text":"actively developing...","title":"jobs"},{"location":"reference/math/","text":"math \u00b6 linear algebra \u00b6 numerical concepts \u00b6 Collection of concepts for numerical types. concepts::Numeric Defines a number, it is the union of std::integral and std::floating_point . concepts :: Numeric < int > == true ; concepts :: Numeric < float > == true ; concepts :: Numeric < str > == false ; concepts::Matrix Defines a matrix-like type with a two dimensional size, a type, and a get member function with constexpr access. The specialization concepts::SquareMatrix is a matrix with the same size on both dimensions. An example of a minimal definition of a matrix is as follows: struct Matrix2x3 { //: value type M :: value_type = int ; //: size constexpr static std :: pair < std :: size_t , std :: size_t > size () { return { 2 , 3 }; } //: reference get template < std :: size_t I , std :: size_t J > constexpr T & get () { ... } //: constant get template < std :: size_t I , std :: size_t J > constexpr T get () const { ... } }; concepts :: Matrix < Matrix2x3 > == true ; concepts :: SquareMatrix < Matrix2x3 > == false ; // 2 != 3 concepts::ColumnVector A column vector is just a matrix of size Nx1 with N > 1. It is the most usual type of vector and the one we specificly define later. There is also a row vector concept, concepts::RowVector , which is a matrix of size 1xN, but it is mainly there to assist with some advanced linear algebra operations that will be rarely used. The concept concepts::Vector is the union of both types of vector. struct Vector4f { //: value type M :: value_type = float ; //: size constexpr static std :: pair < std :: size_t , std :: size_t > size () { return { 4 , 1 }; } //: reference get template < std :: size_t I , std :: size_t J > constexpr T & get () { ... } //: constant get template < std :: size_t I , std :: size_t J > constexpr T get () const { ... } }; concepts :: Matrix < Vector4f > == true ; concepts :: ColumnVector < Vector4f > == true ; concepts :: RowVector < Vector4f > == false ; concepts :: Vector < Vector4f > == true ; functions \u00b6 All operations defined in the algebra library are constant expressions, meaning that they can be resolved at compile time (for constexpr variables) and save performance on runtime. This is the main motivation to have a templated get member function instead of a regular lookup. scalar operations on vectors/matrices M mat ; // M satisfies concepts::Matrix T scalar ; // T satisfies concepts::Numeric and it is the same as M::value_type //: scalar multiplication M result = mat * scalar ; M result = scalar * mat ; mat *= scalar ; //: scalar division M result = mat / scalar ; mat /= scalar ; arithmetic operations on vectors/matrices M a , b ; // M satisfies concepts::Matrix //: sum M result = a + b ; a += b ; //: difference M result = a - b ; a -= b ; comparison operations on vectors/matrices M a , b ; // M satisfies concepts::Matrix //: equality bool result = a == b ; //: inequality bool result = a != b ; //: less than (element wise less comparison, returns true if **all** elements are less) bool result = a < b ; vector specific operations Note: technically opearations on vectors mostly require one of them to be a column vector and the other to be a row vector, but for simplicity fresa allows operations between two vectors of the same type (for example two column vectors) to be performed correctly. There are special overloads to handle special cases with column with row vector operations in the matrix section. // V satisfies concepts::Vector // CV satisfies concepts::ColumnVector // T satisfies concepts::Numeric and it is the same as V::value_type // S satisfies concepts::Numeric but not necesarily the same type as V::value_type //: dot product V a , b ; T result = dot ( a , b ) == a * b //: cross product CV a , b ; // The vector size must be 3. CV result = cross ( a , b ); //: norm V v ; S result = norm ( v ); //: normalized vector (unit length) V v ; V result = normalize ( v ); //: angle between vectors (in radians) V a , b ; S result = angle ( a , b ); //: angles with respect to the coordinate axis CV v ; S result_x = angle_x ( v ); S result_y = angle_y ( v ); S result_z = angle_z ( v ); matrix product //: general matrix product // A, B and M satisfy concepts::Matrix // the sizes must be compatible, meaning A=AIxAJ, B=BIxBJ, M=MIxMJ with AJ==BI, MI==AI, MJ==BJ // it is in general non conmutative, a*b != b*a A a ; B b ; M result = dot < M , A , B > ( a , b ); //: square matrix product // notation can be simplified for square matrices since A = B = M -> SM (concepts::SquareMatrix) SM a , b ; SM result = dot ( a , b ) == a * b ; //: vector-matrix products // similarly, notation can be simplified for vector multiplication // note that the size of the vector must equal the size of the square matrix (3x3 by 3x1 for example) // also keep in mind the order of multiplication since only the one defined below is defined // column vectors CV c ; SM m ; CV result = dot ( m , c ) == m * c ; // row vectors RV r ; SM m ; RV result = dot ( r , m ) == r * m ; While row by column vector operations are already well defined by the regular dot product (since the result is a scalar), column by row vector operations produce a matrix and would require extensive syntax. Therefore a specialization exists only for fresa defined types ( Vec2/3 , RVec2/3 and Mat ) that allows a simple dot operator syntax. Vec3 < T > c ; RVec3 < T > r ; //: row by column vector, scalar (already well defined) T result = dot ( r , c ) == r * c //: column by row vector, matrix Mat3 < T > result = dot ( c , v ) == c * v ; // equivalent to Mat3<T> result = dot<Mat3<t>>(c, v); other matrix operations //: transpose M m ; M result = transpose ( m ); //: determinant and inverse implementations are defined on [mermelada/extras](https://github.com/josekoalas/mermelada/blob/main/extras/_linear_algebra.h). i am not 100% happy with the clarity and performance of current implementation so they are not imported directly in the project, but are fully functional and can be used. vector implementation \u00b6 fresa provides predefined implementations for a series of types that satisfie concepts::ColumnVector . 2D vector Vec2 < T > v ; concepts :: ColumnVector < decltype ( v ) > == true ; //: size v . size () == { 2 , 1 }; //: vector components v . x == v . template get < 0 , 0 > and v . y == v . template get < 1 , 0 > ; 3D vector Vec3 < T > v ; concepts :: ColumnVector < decltype ( v ) > == true ; //: size v . size () == { 3 , 1 }; //: vector components v . x == v . template get < 0 , 0 > and v . y == v . template get < 1 , 0 > and v . z == v . template get < 2 , 0 > ; matrix implementation \u00b6 There is also an implementation for a generic NxM matrix that satisfies concepts::Matrix using an std::array of size N*M. To retrieve an element using the specification defined get<I, J> function it uses the index of the array data[I * M + J] . Specializations exist for commonly used matrix dimensions: Mat < N , M , T > m ; concepts :: Matrix < decltype ( m ) > == true ; //: size m . size () = { N , M }; //: 2x2 matrix Mat2 < T > == Mat < 2 , 2 , T > ; //: 3x3 matrix Mat3 < T > == Mat < 3 , 3 , T > ; //: 4x4 matrix Mat4 < T > == Mat < 4 , 4 , T > ; There are also defined types for the less used row vectors, which for simplicity use the matrix impementation (and therefore dont have .x, .y, ... components available, but they can still be convertible to column vectors). //: 2D row vector RVec2 < T > == Mat < 1 , 2 , T > ; //: 3D row vector RVec3 < T > == Mat < 1 , 3 , T > ; type transformations \u00b6 Matrix-like objects can be converted to other types of the same characteristics that satisfy the same concepts. //: convert to compatible type (same size) // A and B both satisfy concepts::Matrix, but are different types A a ; B b = to < B > ( a ); One specialization for fresa defined types ( Mat , Vec2 and Vec3 ) is to be able to convert between value types without having to specity the entire name, for example: Vec2 < int > a ; Vec2 < float > b = to < float > ( a ); //: the other possibility without specialization is Vec2<float> b = to<Vec2<float>>(a); There are specializations for column and row vectors, allowing conversions between the two despite not technically having the same two dimensional size. For example a 3x1 column vector can be converted to a 1x3 row vector. //: CV satisfies concepts::ColumnVector and RV satisfies concepts::RowVector //: to column vector RV r ; CV c = to_column < CV > ( r ); //: to row vector CV c ; RV r = to_row < RV > ( c ); pre-defined matrices \u00b6 identity matrix An identity matrix constexpr can be generated for any type that satisfies concepts::SquareMatrix . There are also specializations for the fresa defined type Mat , specifying only the type and dimension. //: general matrix identity M i = identity < M > //: fresa matrix identity Mat3 < int > i = identity < int , 3 > (); random number generator \u00b6 fresa has a random number generator based on the <random> library. It uses a Mersenne Twister engine (by Matsumoto and Nishimura), either mt19937 or mt19937_64 depending on the bytes required. T fresa :: random ( T min , T max ) // with T = concepts::Numeric The random function returns a number between min and max (closed interval, so both included) using a uniform distribution, with support for both integral and floating point types. The default type for the template parameter T is int . Some examples: int random ( 0 , 100 ) = 37 ; float random < float > ( 0.f , 1.f ) = 0.37f ; ui64 random < ui64 > ( 0 , 5 ) = 4 ; general math functions \u00b6 factorials \u00b6 The function factorial<N>() provides a constexpr factorial for \\(N!\\) . Similarly, binomial<N, K>() returns the combinatorial number N over K. A helper function pascal_triangle<N>() returns an array of size N+1 with the elements of the Nth row of the pascal triangle (with 0 being the first row). constexpr powers \u00b6 The function std::pow does not allow for constexpr powers, so pow<N>(x) has been added, providing a constant expression for integer positive powers of x. interpolation \u00b6 The interpolate function allows for interpolation between a and b using t as a parameter. Without any more parameters it uses linear interpolation, but a function can be passed to be aplied to t before interpolation, such as smoothstep. auto c = interpolate ( a , b , t ); auto c = interpolate ( a , b , t , func ) == interpolate ( a , b , func ( t )); interpolate ( a , b , 0.0 ) == a ; interpolate ( a , b , 1.0 ) == b ; smoothstep \u00b6 A smoothstep function is a sigmoid-like interpolation function that transitions smoothly between 0 and 1, with inputs lower than 0 being always 0 and inputs greater than 1 being 1. There are different orders of the smoothstep function: \\(S_0\\) : Behaves like a clamping function. \\(S_1\\) : Classical smoothstep function, same as implemented in glsl . Its main term is the 3rd degree polinomial \\(-2x^3 + 3x^2\\) . \\(S_2\\) : Often called smootherstep . It uses a 5th degree polinomial, \\(6x^5 - 15x^4 + 10x^3\\) . The function smoothstep<N>(x) returns the smoothstep interpolation of order N. If no order is specified, it defaults to N = 1. auto c = interpolate ( a , b , t , smoothstep < N , T > ); cosine interpolation \u00b6 auto c = interpolate ( a , b , t , cos_interpolation < T > ); cubic interpolation \u00b6 auto c = interpolate ( a , b , t , pow < 3 , T > );","title":"math"},{"location":"reference/math/#math","text":"","title":"math"},{"location":"reference/math/#linear-algebra","text":"","title":"linear algebra"},{"location":"reference/math/#numerical-concepts","text":"Collection of concepts for numerical types. concepts::Numeric Defines a number, it is the union of std::integral and std::floating_point . concepts :: Numeric < int > == true ; concepts :: Numeric < float > == true ; concepts :: Numeric < str > == false ; concepts::Matrix Defines a matrix-like type with a two dimensional size, a type, and a get member function with constexpr access. The specialization concepts::SquareMatrix is a matrix with the same size on both dimensions. An example of a minimal definition of a matrix is as follows: struct Matrix2x3 { //: value type M :: value_type = int ; //: size constexpr static std :: pair < std :: size_t , std :: size_t > size () { return { 2 , 3 }; } //: reference get template < std :: size_t I , std :: size_t J > constexpr T & get () { ... } //: constant get template < std :: size_t I , std :: size_t J > constexpr T get () const { ... } }; concepts :: Matrix < Matrix2x3 > == true ; concepts :: SquareMatrix < Matrix2x3 > == false ; // 2 != 3 concepts::ColumnVector A column vector is just a matrix of size Nx1 with N > 1. It is the most usual type of vector and the one we specificly define later. There is also a row vector concept, concepts::RowVector , which is a matrix of size 1xN, but it is mainly there to assist with some advanced linear algebra operations that will be rarely used. The concept concepts::Vector is the union of both types of vector. struct Vector4f { //: value type M :: value_type = float ; //: size constexpr static std :: pair < std :: size_t , std :: size_t > size () { return { 4 , 1 }; } //: reference get template < std :: size_t I , std :: size_t J > constexpr T & get () { ... } //: constant get template < std :: size_t I , std :: size_t J > constexpr T get () const { ... } }; concepts :: Matrix < Vector4f > == true ; concepts :: ColumnVector < Vector4f > == true ; concepts :: RowVector < Vector4f > == false ; concepts :: Vector < Vector4f > == true ;","title":"numerical concepts"},{"location":"reference/math/#functions","text":"All operations defined in the algebra library are constant expressions, meaning that they can be resolved at compile time (for constexpr variables) and save performance on runtime. This is the main motivation to have a templated get member function instead of a regular lookup. scalar operations on vectors/matrices M mat ; // M satisfies concepts::Matrix T scalar ; // T satisfies concepts::Numeric and it is the same as M::value_type //: scalar multiplication M result = mat * scalar ; M result = scalar * mat ; mat *= scalar ; //: scalar division M result = mat / scalar ; mat /= scalar ; arithmetic operations on vectors/matrices M a , b ; // M satisfies concepts::Matrix //: sum M result = a + b ; a += b ; //: difference M result = a - b ; a -= b ; comparison operations on vectors/matrices M a , b ; // M satisfies concepts::Matrix //: equality bool result = a == b ; //: inequality bool result = a != b ; //: less than (element wise less comparison, returns true if **all** elements are less) bool result = a < b ; vector specific operations Note: technically opearations on vectors mostly require one of them to be a column vector and the other to be a row vector, but for simplicity fresa allows operations between two vectors of the same type (for example two column vectors) to be performed correctly. There are special overloads to handle special cases with column with row vector operations in the matrix section. // V satisfies concepts::Vector // CV satisfies concepts::ColumnVector // T satisfies concepts::Numeric and it is the same as V::value_type // S satisfies concepts::Numeric but not necesarily the same type as V::value_type //: dot product V a , b ; T result = dot ( a , b ) == a * b //: cross product CV a , b ; // The vector size must be 3. CV result = cross ( a , b ); //: norm V v ; S result = norm ( v ); //: normalized vector (unit length) V v ; V result = normalize ( v ); //: angle between vectors (in radians) V a , b ; S result = angle ( a , b ); //: angles with respect to the coordinate axis CV v ; S result_x = angle_x ( v ); S result_y = angle_y ( v ); S result_z = angle_z ( v ); matrix product //: general matrix product // A, B and M satisfy concepts::Matrix // the sizes must be compatible, meaning A=AIxAJ, B=BIxBJ, M=MIxMJ with AJ==BI, MI==AI, MJ==BJ // it is in general non conmutative, a*b != b*a A a ; B b ; M result = dot < M , A , B > ( a , b ); //: square matrix product // notation can be simplified for square matrices since A = B = M -> SM (concepts::SquareMatrix) SM a , b ; SM result = dot ( a , b ) == a * b ; //: vector-matrix products // similarly, notation can be simplified for vector multiplication // note that the size of the vector must equal the size of the square matrix (3x3 by 3x1 for example) // also keep in mind the order of multiplication since only the one defined below is defined // column vectors CV c ; SM m ; CV result = dot ( m , c ) == m * c ; // row vectors RV r ; SM m ; RV result = dot ( r , m ) == r * m ; While row by column vector operations are already well defined by the regular dot product (since the result is a scalar), column by row vector operations produce a matrix and would require extensive syntax. Therefore a specialization exists only for fresa defined types ( Vec2/3 , RVec2/3 and Mat ) that allows a simple dot operator syntax. Vec3 < T > c ; RVec3 < T > r ; //: row by column vector, scalar (already well defined) T result = dot ( r , c ) == r * c //: column by row vector, matrix Mat3 < T > result = dot ( c , v ) == c * v ; // equivalent to Mat3<T> result = dot<Mat3<t>>(c, v); other matrix operations //: transpose M m ; M result = transpose ( m ); //: determinant and inverse implementations are defined on [mermelada/extras](https://github.com/josekoalas/mermelada/blob/main/extras/_linear_algebra.h). i am not 100% happy with the clarity and performance of current implementation so they are not imported directly in the project, but are fully functional and can be used.","title":"functions"},{"location":"reference/math/#vector-implementation","text":"fresa provides predefined implementations for a series of types that satisfie concepts::ColumnVector . 2D vector Vec2 < T > v ; concepts :: ColumnVector < decltype ( v ) > == true ; //: size v . size () == { 2 , 1 }; //: vector components v . x == v . template get < 0 , 0 > and v . y == v . template get < 1 , 0 > ; 3D vector Vec3 < T > v ; concepts :: ColumnVector < decltype ( v ) > == true ; //: size v . size () == { 3 , 1 }; //: vector components v . x == v . template get < 0 , 0 > and v . y == v . template get < 1 , 0 > and v . z == v . template get < 2 , 0 > ;","title":"vector implementation"},{"location":"reference/math/#matrix-implementation","text":"There is also an implementation for a generic NxM matrix that satisfies concepts::Matrix using an std::array of size N*M. To retrieve an element using the specification defined get<I, J> function it uses the index of the array data[I * M + J] . Specializations exist for commonly used matrix dimensions: Mat < N , M , T > m ; concepts :: Matrix < decltype ( m ) > == true ; //: size m . size () = { N , M }; //: 2x2 matrix Mat2 < T > == Mat < 2 , 2 , T > ; //: 3x3 matrix Mat3 < T > == Mat < 3 , 3 , T > ; //: 4x4 matrix Mat4 < T > == Mat < 4 , 4 , T > ; There are also defined types for the less used row vectors, which for simplicity use the matrix impementation (and therefore dont have .x, .y, ... components available, but they can still be convertible to column vectors). //: 2D row vector RVec2 < T > == Mat < 1 , 2 , T > ; //: 3D row vector RVec3 < T > == Mat < 1 , 3 , T > ;","title":"matrix implementation"},{"location":"reference/math/#type-transformations","text":"Matrix-like objects can be converted to other types of the same characteristics that satisfy the same concepts. //: convert to compatible type (same size) // A and B both satisfy concepts::Matrix, but are different types A a ; B b = to < B > ( a ); One specialization for fresa defined types ( Mat , Vec2 and Vec3 ) is to be able to convert between value types without having to specity the entire name, for example: Vec2 < int > a ; Vec2 < float > b = to < float > ( a ); //: the other possibility without specialization is Vec2<float> b = to<Vec2<float>>(a); There are specializations for column and row vectors, allowing conversions between the two despite not technically having the same two dimensional size. For example a 3x1 column vector can be converted to a 1x3 row vector. //: CV satisfies concepts::ColumnVector and RV satisfies concepts::RowVector //: to column vector RV r ; CV c = to_column < CV > ( r ); //: to row vector CV c ; RV r = to_row < RV > ( c );","title":"type transformations"},{"location":"reference/math/#pre-defined-matrices","text":"identity matrix An identity matrix constexpr can be generated for any type that satisfies concepts::SquareMatrix . There are also specializations for the fresa defined type Mat , specifying only the type and dimension. //: general matrix identity M i = identity < M > //: fresa matrix identity Mat3 < int > i = identity < int , 3 > ();","title":"pre-defined matrices"},{"location":"reference/math/#random-number-generator","text":"fresa has a random number generator based on the <random> library. It uses a Mersenne Twister engine (by Matsumoto and Nishimura), either mt19937 or mt19937_64 depending on the bytes required. T fresa :: random ( T min , T max ) // with T = concepts::Numeric The random function returns a number between min and max (closed interval, so both included) using a uniform distribution, with support for both integral and floating point types. The default type for the template parameter T is int . Some examples: int random ( 0 , 100 ) = 37 ; float random < float > ( 0.f , 1.f ) = 0.37f ; ui64 random < ui64 > ( 0 , 5 ) = 4 ;","title":"random number generator"},{"location":"reference/math/#general-math-functions","text":"","title":"general math functions"},{"location":"reference/math/#factorials","text":"The function factorial<N>() provides a constexpr factorial for \\(N!\\) . Similarly, binomial<N, K>() returns the combinatorial number N over K. A helper function pascal_triangle<N>() returns an array of size N+1 with the elements of the Nth row of the pascal triangle (with 0 being the first row).","title":"factorials"},{"location":"reference/math/#constexpr-powers","text":"The function std::pow does not allow for constexpr powers, so pow<N>(x) has been added, providing a constant expression for integer positive powers of x.","title":"constexpr powers"},{"location":"reference/math/#interpolation","text":"The interpolate function allows for interpolation between a and b using t as a parameter. Without any more parameters it uses linear interpolation, but a function can be passed to be aplied to t before interpolation, such as smoothstep. auto c = interpolate ( a , b , t ); auto c = interpolate ( a , b , t , func ) == interpolate ( a , b , func ( t )); interpolate ( a , b , 0.0 ) == a ; interpolate ( a , b , 1.0 ) == b ;","title":"interpolation"},{"location":"reference/math/#smoothstep","text":"A smoothstep function is a sigmoid-like interpolation function that transitions smoothly between 0 and 1, with inputs lower than 0 being always 0 and inputs greater than 1 being 1. There are different orders of the smoothstep function: \\(S_0\\) : Behaves like a clamping function. \\(S_1\\) : Classical smoothstep function, same as implemented in glsl . Its main term is the 3rd degree polinomial \\(-2x^3 + 3x^2\\) . \\(S_2\\) : Often called smootherstep . It uses a 5th degree polinomial, \\(6x^5 - 15x^4 + 10x^3\\) . The function smoothstep<N>(x) returns the smoothstep interpolation of order N. If no order is specified, it defaults to N = 1. auto c = interpolate ( a , b , t , smoothstep < N , T > );","title":"smoothstep"},{"location":"reference/math/#cosine-interpolation","text":"auto c = interpolate ( a , b , t , cos_interpolation < T > );","title":"cosine interpolation"},{"location":"reference/math/#cubic-interpolation","text":"auto c = interpolate ( a , b , t , pow < 3 , T > );","title":"cubic interpolation"},{"location":"reference/time/","text":"time \u00b6 Small time management utility based on std::chrono . Defines helpful functions to manage the flow of time. It also imports the chrono literals for time, for example, 1ms . The clock implementation is std::chrono::steady_clock , aliased as fresa::clock . The main function of the library is fresa::time() , which returns the current point in time.","title":"time"},{"location":"reference/time/#time","text":"Small time management utility based on std::chrono . Defines helpful functions to manage the flow of time. It also imports the chrono literals for time, for example, 1ms . The clock implementation is std::chrono::steady_clock , aliased as fresa::clock . The main function of the library is fresa::time() , which returns the current point in time.","title":"time"},{"location":"reference/types/","text":"custom types \u00b6 standard types \u00b6 Defines standard library imports and useful aliases. Also includes feature testing for the latest c++20 features, which in case they are not available it replaces them with compatible libraries. standard library features \u00b6 Features from the standard library will be added with a clear intent, trying to keep them as organized as possible. All imports used will be listed in this file. math <cstdint> for standard integer types <random> for generating pseudo-random numbers <numbers> for mathematical constants, including pi std::clamp strings std::string (aliased as str ) std::string_view (aliased as str_view) containers common: std::array as the main container, use wherever possible std::vector only for containers that must be variable, preallocation is recommended std::unordered_map for key-value pairs std::map only when ordered access is required <ranges> [ c++20 ] for algorithms and iteration specific: std::deque for lists where a lot of elements are added to or removed at the back std::set for unique identifier lists, has useful mathematical properties std::stack for LIFO containers, for example, system initialization/destruction std::queue and std::priority_queue for other ordered containers metaprograming templates lambdas (and templated lambdas [ c++20 ]) concepts [ c++20 ] std::optional <tuple> compiler feature testing [ c++20 ] std::source_location [ c++20 ] for unit testing (alternative implementation provided) time std::chrono for system independent timers concurrency coroutines [ c++20 ] std::jthread [ c++20 ] for multithreading std::atomic , std::mutex and std::condition_variable for thread syncronization aliases \u00b6 Some standard types are aliased to improve on readability and code clutter. Also, this is made to avoid using the std namespace, as that can bring confusion and errors. I tried to use common and easy to understand aliases, and a table is available with all conversions: type alias std::uint8_t ui8 std::uint16_t ui16 std::uint32_t ui32 std::uint64_t ui64 std::string str std::string_view str_view The namespace aliases are mainly to allow compatibility between the standard library and helper libraries while compilers get support of c++20 . For example, the range-v3 library defines everything in the namespace ranges , while the standard library uses std::ranges . Similarly, in clang coroutine features are under std::experimental , while on gcc they are under std . Once the libraries are homogeneous this aliases might be removed. namespace alias std::ranges ranges std::ranges::views rv std::experimental std_ type name \u00b6 Constexpr compiler-independent type name implementation. constexpr str_view fresa :: type_name_n < TYPE > (); constexpr str_view fresa :: type_name < TYPE > (); There are two versions of the function. type_name_n returns the full type including all namespaces, while type_name removes fresa namespaces and only returns the name of the type. type_name_n < fresa :: detail :: array > () == \"fresa::detail::array\" ; type_name < fresa :: detail :: array > () == \"array\" ; //: while type_name_n < std :: array > () == \"std::array\" ; type_name < std :: array > () == \"std::array\" ; constexpr for \u00b6 Approach of a variety of constexpr for loops. Uses template metaprograming to create the iteration on compile time, supporting constexpr results. integral for Similar to a regular for loop, has a range of integral values [a, b) and calls the function inside each time with a different value of i . In the case of the constexpr for, i is an integral constant which can be used as a constexpr, for example for template parameters. //: regular for for ( int i = 0 ; i < 5 ; i ++ ) { ... } //: constexpr for for_ < 0 , 5 > ([ & ]( auto i ){ ... }); //: also supports a custom increment for_ < 0 , 30 , 3 > ([]( auto i ){ ... }); parameter pack for Recursively calls the function with each of the elements provided. The values can be heterogeneous. for_ ([ & ]( auto a ){ ... }, 2 , 4 , 8 , 16 ); tuple like for Very similar to the previous one, but perhaps more useful. Iterates over the values of a tuple like object, much like a range based for loop. //: range based for loop for ( auto a : some_array ) { ... } //: constexpr tuple-like for loop for_ ([ & ]( auto const & a ){ ... }, std :: make_tuple ( true , 1 , \"hello\" )); string utils \u00b6 string literal Used for passing a string literal as a template parameter. template < str_literal name > void function () { name . value ; } function < \"hey\" > (); lowercase Returns a lowercase string view. Works for constexpr strings. There is also a literal operator for in place conversion. fresa :: lower ( \"FrEsA\" ) == \"fresa\" \"MeRmElAdA\" _lower == \"mermelada\" split Parses a string view and returns a range of elements separated by the delimiter (by default a space). The returned object is a range, but can be easily convertible to a vector using ranges::to_vector . auto s_range = split ( \"a,b,c,d\" , ',' ); auto s_vector = s_range | ranges :: to_vector ; //: removes extra delimiters auto s = split ( \"a b c d\" ) | ranges :: to_vector == { \"a\" , \"b\" , \"c\" , \"d\" }; atomic queue \u00b6 spin lock Simple implementation of a spin lock using std::atomic_flag for thread syncronization. Can be used inside std::lock_guard . fresa :: SpinLock lock ; //... { std :: lock_guard < SpinLock > guard ( lock ); //: thread safe code } atomic queue Adaptation of std::queue to be thread safe using SpinLock . Can't be copied, only moved (for example, to emplace in a vector or atomic queues). One of its main usages is for the job system 's worker queues. fresa :: AtomicQueue < T > queue ; //: add to the end of the queue queue . push ( T {}); //: get an item from the front of the queue and remove it // if the queue is empty, return an empty optional std :: optional < T > t = queue . pop (); //: elements left in the queue std :: size_t n = queue . size (); //: clear the queue queue . clear (); coroutines \u00b6 See coroutines . strong types \u00b6 A reimplementation of rollbear's strong type library. The functionality and usage is mostly the same, but I simplified it a bit for our usecase and used concepts instead of SFINAE for clarity since c++20 is already required for the rest of the engine. All credits go to their implementation. To describe a strong type alias you do the following: #include \"strong_types.h\" using IntLike = strong :: Type < int , decltype ([]{}), strong :: Regular , ... > ; The first parameter of strong::Type is the type you are aliasing. The second is a tag, which is an unique template parameter to keep different strong types distinct. We can use the lambda return type for this since it is always guaranteed to be unique, written as decltype([]{}) . Finally, a list of modifiers can be optionally specified. These are passthroughs added to the strong type to allow easier manipulation and functionality. modifiers Equality and EqualityWith<T> provide equality operators ( == and != ) with the same type and with another type T respectively. This extra type can be strong or regular, but can't be the same type you are defining (for that you can use the regular Equality ). Ordered and OrderedWith<T> provide comparison operators ( < , > , <= and >= ). Semiregular is default constructible, move and copy constructible, move and copy assignable and swappable. Regular extends all semiregular requirements while also being equality comparable. Recommended base type. Unique makes the type move constructible and assignable but not copy constructible or assignable. Incrementable provides increment operators ( ++ and -- ). For exclusive increment or decrement use detail::OnlyIncrementable and detail::OnlyDecrementable . Boolean gives the type a cast to bool , for example, to use inside if statements. OStreamable , IStreamable and IOStreamable pass the stream operators ( << and >> ) to the base type. Arithmetic and ArithmeticWith<T> provide arithmetic operators ( + , - , * , / and % ), as well as the corresponding assignment operators ( += , -= , *= , /= and %= ). Bitwise and BitwiseWith<T> provide bitwise operators ( & , | , ^ , << and >> ), as well as the corresponding assigment operators ( &= , |= , ^= , <<= and >>= ). Indexed allows to access the base type indices using [] and .at() . Iterator adds functionality depending on the iterator type. Range allows to iterate over the elements. Defines begin and end , as well as cbegin and cend . You can use the type inside a range based for loop. ConvertibleTo<T> gives the type an explicit cast to T . ImplicitlyConvertibleTo<T> gives it an implicit cast. Use the latter with caution since it can defeat the whole point of having a separate strong type. Hashable<T> spetializes std::hash to take this strong type. Allows to use it as a key in an std::unordered_map . Inherits Equality . Formattable<T> spetializes fmt::format if the library is available. Allows to use log to print it.","title":"custom types"},{"location":"reference/types/#custom-types","text":"","title":"custom types"},{"location":"reference/types/#standard-types","text":"Defines standard library imports and useful aliases. Also includes feature testing for the latest c++20 features, which in case they are not available it replaces them with compatible libraries.","title":"standard types"},{"location":"reference/types/#standard-library-features","text":"Features from the standard library will be added with a clear intent, trying to keep them as organized as possible. All imports used will be listed in this file. math <cstdint> for standard integer types <random> for generating pseudo-random numbers <numbers> for mathematical constants, including pi std::clamp strings std::string (aliased as str ) std::string_view (aliased as str_view) containers common: std::array as the main container, use wherever possible std::vector only for containers that must be variable, preallocation is recommended std::unordered_map for key-value pairs std::map only when ordered access is required <ranges> [ c++20 ] for algorithms and iteration specific: std::deque for lists where a lot of elements are added to or removed at the back std::set for unique identifier lists, has useful mathematical properties std::stack for LIFO containers, for example, system initialization/destruction std::queue and std::priority_queue for other ordered containers metaprograming templates lambdas (and templated lambdas [ c++20 ]) concepts [ c++20 ] std::optional <tuple> compiler feature testing [ c++20 ] std::source_location [ c++20 ] for unit testing (alternative implementation provided) time std::chrono for system independent timers concurrency coroutines [ c++20 ] std::jthread [ c++20 ] for multithreading std::atomic , std::mutex and std::condition_variable for thread syncronization","title":"standard library features"},{"location":"reference/types/#aliases","text":"Some standard types are aliased to improve on readability and code clutter. Also, this is made to avoid using the std namespace, as that can bring confusion and errors. I tried to use common and easy to understand aliases, and a table is available with all conversions: type alias std::uint8_t ui8 std::uint16_t ui16 std::uint32_t ui32 std::uint64_t ui64 std::string str std::string_view str_view The namespace aliases are mainly to allow compatibility between the standard library and helper libraries while compilers get support of c++20 . For example, the range-v3 library defines everything in the namespace ranges , while the standard library uses std::ranges . Similarly, in clang coroutine features are under std::experimental , while on gcc they are under std . Once the libraries are homogeneous this aliases might be removed. namespace alias std::ranges ranges std::ranges::views rv std::experimental std_","title":"aliases"},{"location":"reference/types/#type-name","text":"Constexpr compiler-independent type name implementation. constexpr str_view fresa :: type_name_n < TYPE > (); constexpr str_view fresa :: type_name < TYPE > (); There are two versions of the function. type_name_n returns the full type including all namespaces, while type_name removes fresa namespaces and only returns the name of the type. type_name_n < fresa :: detail :: array > () == \"fresa::detail::array\" ; type_name < fresa :: detail :: array > () == \"array\" ; //: while type_name_n < std :: array > () == \"std::array\" ; type_name < std :: array > () == \"std::array\" ;","title":"type name"},{"location":"reference/types/#constexpr-for","text":"Approach of a variety of constexpr for loops. Uses template metaprograming to create the iteration on compile time, supporting constexpr results. integral for Similar to a regular for loop, has a range of integral values [a, b) and calls the function inside each time with a different value of i . In the case of the constexpr for, i is an integral constant which can be used as a constexpr, for example for template parameters. //: regular for for ( int i = 0 ; i < 5 ; i ++ ) { ... } //: constexpr for for_ < 0 , 5 > ([ & ]( auto i ){ ... }); //: also supports a custom increment for_ < 0 , 30 , 3 > ([]( auto i ){ ... }); parameter pack for Recursively calls the function with each of the elements provided. The values can be heterogeneous. for_ ([ & ]( auto a ){ ... }, 2 , 4 , 8 , 16 ); tuple like for Very similar to the previous one, but perhaps more useful. Iterates over the values of a tuple like object, much like a range based for loop. //: range based for loop for ( auto a : some_array ) { ... } //: constexpr tuple-like for loop for_ ([ & ]( auto const & a ){ ... }, std :: make_tuple ( true , 1 , \"hello\" ));","title":"constexpr for"},{"location":"reference/types/#string-utils","text":"string literal Used for passing a string literal as a template parameter. template < str_literal name > void function () { name . value ; } function < \"hey\" > (); lowercase Returns a lowercase string view. Works for constexpr strings. There is also a literal operator for in place conversion. fresa :: lower ( \"FrEsA\" ) == \"fresa\" \"MeRmElAdA\" _lower == \"mermelada\" split Parses a string view and returns a range of elements separated by the delimiter (by default a space). The returned object is a range, but can be easily convertible to a vector using ranges::to_vector . auto s_range = split ( \"a,b,c,d\" , ',' ); auto s_vector = s_range | ranges :: to_vector ; //: removes extra delimiters auto s = split ( \"a b c d\" ) | ranges :: to_vector == { \"a\" , \"b\" , \"c\" , \"d\" };","title":"string utils"},{"location":"reference/types/#atomic-queue","text":"spin lock Simple implementation of a spin lock using std::atomic_flag for thread syncronization. Can be used inside std::lock_guard . fresa :: SpinLock lock ; //... { std :: lock_guard < SpinLock > guard ( lock ); //: thread safe code } atomic queue Adaptation of std::queue to be thread safe using SpinLock . Can't be copied, only moved (for example, to emplace in a vector or atomic queues). One of its main usages is for the job system 's worker queues. fresa :: AtomicQueue < T > queue ; //: add to the end of the queue queue . push ( T {}); //: get an item from the front of the queue and remove it // if the queue is empty, return an empty optional std :: optional < T > t = queue . pop (); //: elements left in the queue std :: size_t n = queue . size (); //: clear the queue queue . clear ();","title":"atomic queue"},{"location":"reference/types/#coroutines","text":"See coroutines .","title":"coroutines"},{"location":"reference/types/#strong-types","text":"A reimplementation of rollbear's strong type library. The functionality and usage is mostly the same, but I simplified it a bit for our usecase and used concepts instead of SFINAE for clarity since c++20 is already required for the rest of the engine. All credits go to their implementation. To describe a strong type alias you do the following: #include \"strong_types.h\" using IntLike = strong :: Type < int , decltype ([]{}), strong :: Regular , ... > ; The first parameter of strong::Type is the type you are aliasing. The second is a tag, which is an unique template parameter to keep different strong types distinct. We can use the lambda return type for this since it is always guaranteed to be unique, written as decltype([]{}) . Finally, a list of modifiers can be optionally specified. These are passthroughs added to the strong type to allow easier manipulation and functionality. modifiers Equality and EqualityWith<T> provide equality operators ( == and != ) with the same type and with another type T respectively. This extra type can be strong or regular, but can't be the same type you are defining (for that you can use the regular Equality ). Ordered and OrderedWith<T> provide comparison operators ( < , > , <= and >= ). Semiregular is default constructible, move and copy constructible, move and copy assignable and swappable. Regular extends all semiregular requirements while also being equality comparable. Recommended base type. Unique makes the type move constructible and assignable but not copy constructible or assignable. Incrementable provides increment operators ( ++ and -- ). For exclusive increment or decrement use detail::OnlyIncrementable and detail::OnlyDecrementable . Boolean gives the type a cast to bool , for example, to use inside if statements. OStreamable , IStreamable and IOStreamable pass the stream operators ( << and >> ) to the base type. Arithmetic and ArithmeticWith<T> provide arithmetic operators ( + , - , * , / and % ), as well as the corresponding assignment operators ( += , -= , *= , /= and %= ). Bitwise and BitwiseWith<T> provide bitwise operators ( & , | , ^ , << and >> ), as well as the corresponding assigment operators ( &= , |= , ^= , <<= and >>= ). Indexed allows to access the base type indices using [] and .at() . Iterator adds functionality depending on the iterator type. Range allows to iterate over the elements. Defines begin and end , as well as cbegin and cend . You can use the type inside a range based for loop. ConvertibleTo<T> gives the type an explicit cast to T . ImplicitlyConvertibleTo<T> gives it an implicit cast. Use the latter with caution since it can defeat the whole point of having a separate strong type. Hashable<T> spetializes std::hash to take this strong type. Allows to use it as a key in an std::unordered_map . Inherits Equality . Formattable<T> spetializes fmt::format if the library is available. Allows to use log to print it.","title":"strong types"},{"location":"reference/tools/assertions/","text":"assertions \u00b6 To check if code is running propperly, fresa includes an assertion system. For code that can be checked at compile time, the standard static_assert() is recommended. However, for runtime code, it includes fresa_assert() . It is used like so: void something ( int i ) { fresa_assert ( i > 0 , \"i must be greater than 0\" ); // ... } If the assertion fails, the program will abort and print a message along with the file and line of the error. If it passes, nothing will happen. Runtime assertions have a small performance penalty since they have to check if the condition is met at runtime, but they are useful debugging tools. Assertions are disabled by default, and should be only used for debugging, not production code. The flag to enable them is inside the engine configuration , called enable_assertions() . If you want to pass a formatted string, you can do so, but you must manually specify the template parameters of the format arguments. This is needed since the function also takes the source location to display where the assertion is failing, so if the arguments are not specified the default value of source location is not added, resulting in an error. void something ( int i ) { fresa_assert < int > ( i > 0 , \"i must be greater than 0: {}\" , i ); //: correct fresa_assert ( i > 0 , \"i must be greater than 0: {}\" , i ); //! error // ... }","title":"assertions"},{"location":"reference/tools/assertions/#assertions","text":"To check if code is running propperly, fresa includes an assertion system. For code that can be checked at compile time, the standard static_assert() is recommended. However, for runtime code, it includes fresa_assert() . It is used like so: void something ( int i ) { fresa_assert ( i > 0 , \"i must be greater than 0\" ); // ... } If the assertion fails, the program will abort and print a message along with the file and line of the error. If it passes, nothing will happen. Runtime assertions have a small performance penalty since they have to check if the condition is met at runtime, but they are useful debugging tools. Assertions are disabled by default, and should be only used for debugging, not production code. The flag to enable them is inside the engine configuration , called enable_assertions() . If you want to pass a formatted string, you can do so, but you must manually specify the template parameters of the format arguments. This is needed since the function also takes the source location to display where the assertion is failing, so if the arguments are not specified the default value of source location is not added, resulting in an error. void something ( int i ) { fresa_assert < int > ( i > 0 , \"i must be greater than 0: {}\" , i ); //: correct fresa_assert ( i > 0 , \"i must be greater than 0: {}\" , i ); //! error // ... }","title":"assertions"},{"location":"reference/tools/log/","text":"log \u00b6 fresa has a simple logging system using the fmt library. The function fresa::detail::log is a passthrough to fmt::print with extra parameters for special formatting. fresa :: detail :: log < \"NAME\" , LOG_LEVEL , fmt :: color > ( \"{}\" , ...); > [ NAME ] : ... The name template parameter is the type of log message, LOG_LEVEL is used to enable or disable log types, and a color can be passed to make the output more readable. The first function parameter must be an fmt::format_string . Simplifying, this means that it will behave as a regular string but everywhere there is a \"{}\" it will be replaced with the next argument. Custom printing formats can be passed, for example, as \"{:.2f}\". Leveraging the new features introduced in fmt with c++20 , the passthrough can now use constant expressions to format at compile time. log levels \u00b6 The logging level can be specified using the engine_config.log_level() config parameter. Each log level is defined in a bitwise enum, so they can be granularly combined. log level bit flag LOG_ERROR 1 << 0 LOG_WARNING 1 << 1 LOG_INFO 1 << 2 LOG_GRAPHICS 1 << 3 LOG_TEST 1 << 4 LOG_DEBUG 1 << 5 LOG_JOBS 1 << 6 For example, log_level = 0b0010011 enables logging for errors, warnings and unit test results. predefined log functions \u00b6 There are a number of predetermined log functions as a convenience: function name log level color log::error \"ERROR\" LOG_ERROR red log::warn \"WARN\" LOG_WARN gold log::info \"INFO\" LOG_INFO cornflower_blue log::graphics \"GRAPHICS\" LOG_GRAPHICS dark_turquoise log::debug \"DEBUG\" LOG_DEBUG light_sky_blue","title":"logging"},{"location":"reference/tools/log/#log","text":"fresa has a simple logging system using the fmt library. The function fresa::detail::log is a passthrough to fmt::print with extra parameters for special formatting. fresa :: detail :: log < \"NAME\" , LOG_LEVEL , fmt :: color > ( \"{}\" , ...); > [ NAME ] : ... The name template parameter is the type of log message, LOG_LEVEL is used to enable or disable log types, and a color can be passed to make the output more readable. The first function parameter must be an fmt::format_string . Simplifying, this means that it will behave as a regular string but everywhere there is a \"{}\" it will be replaced with the next argument. Custom printing formats can be passed, for example, as \"{:.2f}\". Leveraging the new features introduced in fmt with c++20 , the passthrough can now use constant expressions to format at compile time.","title":"log"},{"location":"reference/tools/log/#log-levels","text":"The logging level can be specified using the engine_config.log_level() config parameter. Each log level is defined in a bitwise enum, so they can be granularly combined. log level bit flag LOG_ERROR 1 << 0 LOG_WARNING 1 << 1 LOG_INFO 1 << 2 LOG_GRAPHICS 1 << 3 LOG_TEST 1 << 4 LOG_DEBUG 1 << 5 LOG_JOBS 1 << 6 For example, log_level = 0b0010011 enables logging for errors, warnings and unit test results.","title":"log levels"},{"location":"reference/tools/log/#predefined-log-functions","text":"There are a number of predetermined log functions as a convenience: function name log level color log::error \"ERROR\" LOG_ERROR red log::warn \"WARN\" LOG_WARN gold log::info \"INFO\" LOG_INFO cornflower_blue log::graphics \"GRAPHICS\" LOG_GRAPHICS dark_turquoise log::debug \"DEBUG\" LOG_DEBUG light_sky_blue","title":"predefined log functions"},{"location":"reference/tools/unit_test/","text":"unit tests \u00b6 The engine include a simple unit test framework. It works without macros, leveraging lambda functions. Let's start with an example: TestSuite suite ( \"test_name\" , []{ \"test one\" _test = []{ return expect ( 1 == 1 ); }; // passes \"test two\" _test = []{ return expect ( 1 == 2 ); }; // fails }); Here we are creating a test suite, which consists of a name and a function with a series of tests. A test is defined using the literal \"\"_test . The string parameter is the test name for displaying purposes, and this can be assigned to another function that returns an expect call. The function can perform extra calculations, but the return statement must be a boolean expression encapsulated in an expect. If the expression is true, then the test passes, and fails otherwise. To run a test first you need to enable the test system with the preprocessor directive FRESA_ENABLE_TESTS . This directive must encapsulate all test code to allow to remove it easily from production builds. Then, the easiest way to configure which suites are run is to change the engine config parameter run_tests . It must be a comma separated list of test suite's names, like so: constexpr inline struct _EngineConfig : EngineConfig { constexpr str_view virtual run_tests () const { return \"suite_one,suite_two\" ; }; } engine_config ; This code will run the test suites indicated before the engine's startup. If the log level includes LOG_TEST , then the test results will be print to the console. Unit tests are provided for all mayor fresa features, such as type definitions , the math library and the job system . You can check those files to see how suite definitions work in practise. For the sake of organization, all fresa internal tests are located on source files in the tests folder.","title":"unit tests"},{"location":"reference/tools/unit_test/#unit-tests","text":"The engine include a simple unit test framework. It works without macros, leveraging lambda functions. Let's start with an example: TestSuite suite ( \"test_name\" , []{ \"test one\" _test = []{ return expect ( 1 == 1 ); }; // passes \"test two\" _test = []{ return expect ( 1 == 2 ); }; // fails }); Here we are creating a test suite, which consists of a name and a function with a series of tests. A test is defined using the literal \"\"_test . The string parameter is the test name for displaying purposes, and this can be assigned to another function that returns an expect call. The function can perform extra calculations, but the return statement must be a boolean expression encapsulated in an expect. If the expression is true, then the test passes, and fails otherwise. To run a test first you need to enable the test system with the preprocessor directive FRESA_ENABLE_TESTS . This directive must encapsulate all test code to allow to remove it easily from production builds. Then, the easiest way to configure which suites are run is to change the engine config parameter run_tests . It must be a comma separated list of test suite's names, like so: constexpr inline struct _EngineConfig : EngineConfig { constexpr str_view virtual run_tests () const { return \"suite_one,suite_two\" ; }; } engine_config ; This code will run the test suites indicated before the engine's startup. If the log level includes LOG_TEST , then the test results will be print to the console. Unit tests are provided for all mayor fresa features, such as type definitions , the math library and the job system . You can check those files to see how suite definitions work in practise. For the sake of organization, all fresa internal tests are located on source files in the tests folder.","title":"unit tests"}]}