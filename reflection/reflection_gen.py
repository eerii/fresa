# script to autogenerate reflection information for struct members
# this file will inspect the source code of modified header files looking for lines like: '#include "reflection_****.h"'
# then, it will generate reflection information for every struct in that file and write it to 'fresa/../generated/reflection/reflection_****.h'
# reflection names are not required for the engine to run, but they are very useful for debugging

from dataclasses import dataclass
import sys

# get file name

file_path = ""
if len(sys.argv) > 1:
    file_path = sys.argv[1]
else:
    print("usage: python reflection_gen.py <header_file>")
    sys.exit(1)

file_name = file_path.split("/")[-1]

# open header file

f = open(file_path, "r")
lines = f.readlines()
f.close()

# check if file is asking for reflection

is_reflectable = False
has_struct_after_include = False
for l in reversed(lines):
    if l.strip().startswith("struct"):
        has_struct_after_include = True
    if l.strip().startswith("#include") and "\"" in l:
        include_file = l.split("\"")[1]
        if include_file.startswith("reflection_"):
            if include_file != "reflection_" + file_name:
                print(f"{file_name} has a wrong reflection include: {include_file}")
                sys.exit(0)
            if has_struct_after_include:
                print(f"{file_name} has a struct defined after the include, which is not allowed")
                sys.exit(0)
            is_reflectable = True
            break

if not is_reflectable:
    sys.exit(0)

# filter and prepare lines

lines = [l.strip() for l in lines]
lines = [l for l in lines if not (l == "" or l.startswith("//") or l.startswith("#"))]

# find structs

@dataclass
class Struct:
    name : str
    namespace : str
    members : list

structs = []
current_struct = ""
current_struct_index = -1
current_namespace = ""
brackets = ""

for l in lines:
    if l.startswith("namespace"):
        n = l.split(" ")[1].strip("{")
        current_namespace = n if current_namespace == "" else current_namespace + "::" + n
        brackets += "n"
        continue

    if l.startswith("struct"):
        n = l.split(" ")[1].strip("{")
        namespace = current_namespace + ("" if current_struct == "" else "::" + current_struct)
        current_struct = n if current_struct == "" else current_struct + "::" + n
        brackets += "s"
        structs.append(Struct(n, namespace, []))
        current_struct_index = len(structs) - 1
        continue

    if l.startswith("}"):
        last = brackets[-1]
        brackets = brackets[:-1]
        if last == "n":
            current_namespace = "::".join(current_namespace.split("::")[:-1])
        else:
            current_struct = "::".join(current_struct.split("::")[:-1])
            new_struct = current_struct.split("::")[-1]
            for s in reversed(structs):
                if s.name == new_struct:
                    current_struct_index = structs.index(s)
                    break
        continue

    if brackets[-1] == "s":
        if not l.endswith(";"):
            print(f"{file_name} has an invalid line inside a struct: {l}")
            sys.exit(0)
        l = l.strip(";")

        if "static" in l:
            continue
        
        if "=" in l:
            l = l.split("=")[0]

        if "," in l and not "<" in l and not ">" in l:
            names = l.split(",")
            for n in names:
                name = n.strip().split()[-1]
                structs[current_struct_index].members.append(name)
            continue

        name = l.split()[-1]
        structs[current_struct_index].members.append(name)

# begin reflection header

header = f"""//* reflection_{file_name[:-2]}
//      ***THIS IS AN AUTOGENERATED FILE***
//      do not modify manually, reflection_gen.py will run each time a header file is modified
//      reflection_**** are helper files for reflection, they declare the names of the members of a struct
//      these are optional when using the engine, but are very useful for debugging or readable serialization
#pragma once

#include "reflection.h"

namespace fresa
{{
"""

# iterate over structs

for s in structs:
    members = ", ".join([f'"{m}"' for m in s.members])
    header += f"    template <> constexpr auto field_names<{s.namespace}::{s.name}>() {{ return std::array<str_view, {len(s.members)}>{{{members}}}; }}\n"

#Â end reflection header

header += "}"

# write reflection file

f = open(f"generated/reflection/reflection_{file_name}", "w")
f.write(header)
f.close()