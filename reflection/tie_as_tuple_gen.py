# script to autogenerate tie_as_tuple.h up to a given number of arguments
# you can use this file like "python tie_as_tuple_gen.py 16" to generate up to 16 arguments

import sys

# number of fields to generate
number_of_fields = 32
if len(sys.argv) > 1:
    number_of_fields = int(sys.argv[1])

# beginning of generated code
header = f"""//* tie_as_tuple
//      ***THIS IS AN AUTOGENERATED FILE***
//      do not modify, if you need more fields, use tie_as_tuple_gen.py
//      tie as tuple is a helper file for reflection, that decomposes any struct into its fields
//      unfortunately, since c++ does not support varadic structured bindings, we have to do the recursion manually
#pragma once

#include "struct_fields.h"
#include <tuple>

namespace fresa
{{
    template <concepts::Aggregate T>
    constexpr auto tie_as_tuple(T& data) noexcept {{
        constexpr auto fields = field_count_v<T>;
        static_assert(fields <= {number_of_fields}, "max supported members is {number_of_fields}");

        if constexpr (fields == 0) {{
            return std::tie();
        }} """

# iterative template for each field count
for i in range(1, number_of_fields+1):
    members = ", ".join([f"a{j}" for j in range(1, i+1)])
    header += f"""else if constexpr (fields == {i}) {{
            auto& [{members}] = data;
            return std::tie({members});
        }} """

# end of generated code
header += """
    }
}"""

# write to tie_as_tuple.h
f = open("tie_as_tuple.h", "w")
f.write(header)
f.close()