{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"documentation","title":"home"},{"location":"#documentation","text":"","title":"documentation"},{"location":"engine%20design/design/","text":"engine design data oriented design fresa :strawberry: will try to adhere to a data oriented design . Object oriented programming is not always suitable to game engines, it can get too messy too soon. I enjoy designing engines with data in mind, with it being separated from the functions that use it, providing cleaner and easier to debug code. It can also be more performant in a variety of situations. There are many articles detailing how data oriented design can be better for many reasons ( insert reference ), however, I will stick to it since I have made engines in OOD and DOD and I like data programming much better. Please note that this engine will not always be 100% perfectly data oriented, since in some problems it makes more sense to take other approaches. Just a quick note, I have seen many places use DOD and ECS used interchangeably. Though fresa :strawberry: integrates a simple ECS for managing the game entities, an ECS is just an example of what data oriented design can do. It can span all the pieces and frameworks of an engine, it is not wise to reduce it only to an ECS. libraries fresa 's approach to libraries is similar to its approach to language features. Libraries will be only added when they provide a sustancial improvement over hand made code, or at least until I can work on a custom version. For example, vulkan memory allocator significantly improves memory handling in vulkan and it is really well constructed. When choosing a library, its code size will be pretty important. Adding a small one file header library will be preferred to a big and complex project. I will try to only add libraries (or parts of them) which only focus on the problem I'm trying to solve by using them. Also, I would like to be able to easily review all the library code. It will also be nice if they share the same coding style as the engine, for example, with a focus on compile time calculations and with intentful use of new c++ standards. All libraries will be linked in the project template aguacate :avocado: as submodules, under the folder deps , so it is effortless to start a new fresa :strawberry: project with them. They will be also listed here with propper attribution and licensing information. fmt : This library could easily be part of the std library. It is easy to follow, has a really nice syntax and vastly simplifies printing and formatting strings. Besides, it is really performant. I use it as a basis to the logging system ( log.h ), since it also allows to use formatting and colors. It may not be strictly required for our implementation, but a very welcomed quality of life. Also temporary while compilers gain support of std::format . range-v3 : This is a temporary fix since compiler support for the <ranges> of c++20 is not finalised (specially in clang, the compiler I am using). The code will try to import <ranges> , and if not fall back to <range-v3> , which should be pretty much compatible since the standard is based off it. Once compiler support is more widespread it will be removed. jthread : Another temporary fix since std::jthread is not yet supported. Using the library that the standard implementation is based, so there should be no noticeable differences.","title":"engine design"},{"location":"engine%20design/design/#engine-design","text":"","title":"engine design"},{"location":"engine%20design/design/#data-oriented-design","text":"fresa :strawberry: will try to adhere to a data oriented design . Object oriented programming is not always suitable to game engines, it can get too messy too soon. I enjoy designing engines with data in mind, with it being separated from the functions that use it, providing cleaner and easier to debug code. It can also be more performant in a variety of situations. There are many articles detailing how data oriented design can be better for many reasons ( insert reference ), however, I will stick to it since I have made engines in OOD and DOD and I like data programming much better. Please note that this engine will not always be 100% perfectly data oriented, since in some problems it makes more sense to take other approaches. Just a quick note, I have seen many places use DOD and ECS used interchangeably. Though fresa :strawberry: integrates a simple ECS for managing the game entities, an ECS is just an example of what data oriented design can do. It can span all the pieces and frameworks of an engine, it is not wise to reduce it only to an ECS.","title":"data oriented design"},{"location":"engine%20design/design/#libraries","text":"fresa 's approach to libraries is similar to its approach to language features. Libraries will be only added when they provide a sustancial improvement over hand made code, or at least until I can work on a custom version. For example, vulkan memory allocator significantly improves memory handling in vulkan and it is really well constructed. When choosing a library, its code size will be pretty important. Adding a small one file header library will be preferred to a big and complex project. I will try to only add libraries (or parts of them) which only focus on the problem I'm trying to solve by using them. Also, I would like to be able to easily review all the library code. It will also be nice if they share the same coding style as the engine, for example, with a focus on compile time calculations and with intentful use of new c++ standards. All libraries will be linked in the project template aguacate :avocado: as submodules, under the folder deps , so it is effortless to start a new fresa :strawberry: project with them. They will be also listed here with propper attribution and licensing information. fmt : This library could easily be part of the std library. It is easy to follow, has a really nice syntax and vastly simplifies printing and formatting strings. Besides, it is really performant. I use it as a basis to the logging system ( log.h ), since it also allows to use formatting and colors. It may not be strictly required for our implementation, but a very welcomed quality of life. Also temporary while compilers gain support of std::format . range-v3 : This is a temporary fix since compiler support for the <ranges> of c++20 is not finalised (specially in clang, the compiler I am using). The code will try to import <ranges> , and if not fall back to <range-v3> , which should be pretty much compatible since the standard is based off it. Once compiler support is more widespread it will be removed. jthread : Another temporary fix since std::jthread is not yet supported. Using the library that the standard implementation is based, so there should be no noticeable differences.","title":"libraries"},{"location":"engine%20design/features/","text":"language features fresa :strawberry: uses the c++20 standard and some of its most recent features. The std library contains many useful structures and design patterns that were implemented in the past few years. I will carefully pick which features I use and document its usage in this file. This is an opinionated engine, features will be added with a clear intent, keeping clutter to a feasible minimum. These are all my opinions and they are not right nor wrong, just how I like to code now. Keeping performance in mind, a key feature of any game engine on a tight per-frame time budget, compile time calculations and templated code will be a fundamental in the design of this engine. There will also be an active attempt to try to avoid macros (except for conditional compilation) and replace them with safer and more readable alternatives where possible. Macros will always be capitalized and clearly indicated. strings std::string (aliased as str) std::string_view (aliased as str_view) containers common: std::array as the main container, use wherever possible std::vector only for containers that must be variable, preallocation is recommended std::unordered_map for key-value pairs std::map only when ordered access is required ranges ( c++20 ) specific: std::deque for lists where a lot of elements are added to or removed at the back std::set for unique identifier lists, useful mathematical properties std::stack for LIFO containers, for example, system initialization/destruction std::queue and std::priority_queue for other ordered containers metaprograming templates lambdas concepts ( c++20 ) std::optional tuples compiler feature testing ( c++20 ) std::source_location ( c++20 ) for unit testing time std::chrono for system independent timers concurrency coroutines ( c++20 ), using experimental branch for clang compilers std::jthread ( c++20 ) for multithreading std::atomic, std::mutex and std::condition_variable for thread syncronization math random library numbers for several constants, including pi","title":"language features"},{"location":"engine%20design/features/#language-features","text":"fresa :strawberry: uses the c++20 standard and some of its most recent features. The std library contains many useful structures and design patterns that were implemented in the past few years. I will carefully pick which features I use and document its usage in this file. This is an opinionated engine, features will be added with a clear intent, keeping clutter to a feasible minimum. These are all my opinions and they are not right nor wrong, just how I like to code now. Keeping performance in mind, a key feature of any game engine on a tight per-frame time budget, compile time calculations and templated code will be a fundamental in the design of this engine. There will also be an active attempt to try to avoid macros (except for conditional compilation) and replace them with safer and more readable alternatives where possible. Macros will always be capitalized and clearly indicated.","title":"language features"},{"location":"engine%20design/features/#strings","text":"std::string (aliased as str) std::string_view (aliased as str_view)","title":"strings"},{"location":"engine%20design/features/#containers","text":"common: std::array as the main container, use wherever possible std::vector only for containers that must be variable, preallocation is recommended std::unordered_map for key-value pairs std::map only when ordered access is required ranges ( c++20 ) specific: std::deque for lists where a lot of elements are added to or removed at the back std::set for unique identifier lists, useful mathematical properties std::stack for LIFO containers, for example, system initialization/destruction std::queue and std::priority_queue for other ordered containers","title":"containers"},{"location":"engine%20design/features/#metaprograming","text":"templates lambdas concepts ( c++20 ) std::optional tuples","title":"metaprograming"},{"location":"engine%20design/features/#compiler","text":"feature testing ( c++20 ) std::source_location ( c++20 ) for unit testing","title":"compiler"},{"location":"engine%20design/features/#time","text":"std::chrono for system independent timers","title":"time"},{"location":"engine%20design/features/#concurrency","text":"coroutines ( c++20 ), using experimental branch for clang compilers std::jthread ( c++20 ) for multithreading std::atomic, std::mutex and std::condition_variable for thread syncronization","title":"concurrency"},{"location":"engine%20design/features/#math","text":"random library numbers for several constants, including pi","title":"math"},{"location":"engine%20design/style/","text":"coding style naming conventions In fresa :strawberry: we will use the following name conventions for the different types of objects: snake_case : variables, namespaces camelCase : functions PascalCase : structs, interfaces SCREAMING_CASE : constants, macros namespace fresa { constexpr int NUMBER_OF_OBJECTS = 256; struct Object { int position_x; float velocity_y; }; Object registerObject(int start_position) {} #ifdef USE_VULKAN using IPipeline = vkPipeline; #endif } Namespaces will always try to be only one word. Interfaces will start with a capital \"I\". These conventions might be broken when working with elements defined in external libraries, such as vulkan . We will also denote the engine name in fully lowercase letters and accompanied by the strawberry emoji, fresa :strawberry: . All titles of documentation sections will be similarly written in lowercase. comments and documentation //: regular comments //* headers //- todos //? implementation questions //! alert, something went wrong Subsecuent lines of comments (that are not documentation) can be tabbed 2 times to improve readability. It can also be useful to add some extension to the editing software you are using to color code the different comments.","title":"coding style"},{"location":"engine%20design/style/#coding-style","text":"","title":"coding style"},{"location":"engine%20design/style/#naming-conventions","text":"In fresa :strawberry: we will use the following name conventions for the different types of objects: snake_case : variables, namespaces camelCase : functions PascalCase : structs, interfaces SCREAMING_CASE : constants, macros namespace fresa { constexpr int NUMBER_OF_OBJECTS = 256; struct Object { int position_x; float velocity_y; }; Object registerObject(int start_position) {} #ifdef USE_VULKAN using IPipeline = vkPipeline; #endif } Namespaces will always try to be only one word. Interfaces will start with a capital \"I\". These conventions might be broken when working with elements defined in external libraries, such as vulkan . We will also denote the engine name in fully lowercase letters and accompanied by the strawberry emoji, fresa :strawberry: . All titles of documentation sections will be similarly written in lowercase.","title":"naming conventions"},{"location":"engine%20design/style/#comments-and-documentation","text":"//: regular comments //* headers //- todos //? implementation questions //! alert, something went wrong Subsecuent lines of comments (that are not documentation) can be tabbed 2 times to improve readability. It can also be useful to add some extension to the editing software you are using to color code the different comments.","title":"comments and documentation"}]}